+++
title = '计算机组成原理'
date = 2024-10-01T22:48:26+08:00
categories =  ["计算机基础","学习笔记"] 
tags = ["计算机基础","学习笔记","计算机组成原理"]

+++

# 第一章—计算机系统概述

**MAR** 地址寄存器：用于寻址，位数对应存储单元的个数

**MDR** 数据寄存器：位数和存储字长相等

**存储体**由许多存储单元组成，每个**存储单元**包含若干**存储元件**，每个存储元件存储一位二进制代码。存储单元可存储一串二进制代码称这串代码为**存储字**，称这串代码的位数为**存储字长**。

CPU和主存之间通过一组总线相连，总线中有地址、控制和数据三组信号线。MAR中的地址信息会直接送到地址线上，用于指向主存存储单元；控制线中的读/写信号线指出数据是从CPU写入主存还是从主存读出到CPU，根据读操作还是写操作来控制将MDR中的数据是直接送到数据线上，还是将数据线上的数据接收到MDR中。

**字长**：计算机进行一次整数运算所能处理的二进制数据的位数，一般等于内部寄存器的大小，字长越长，计算机精度越高

**数据通路带宽**：指数据总线一次能并线传输信息的位数。

**吞吐量**：指系统在单位时间处理请求的数量。

**响应时间**：用户向计算机发送一个请求，到收到结果的等待时间。

**CPU时钟周期**：主频的倒数，CPU中最小的时间单位，执行指令的每个动作至少需要一个时钟周期

**主频( CPU时钟频率 )**：机器内部主时钟的频率，主频越高，完成指令的一个执行步骤所用的时间越短

*主频通常以 Hz 为单位，1Hz表示每秒一次*

**CPI**：执行一条指令所需的时钟周期数。

**CPU执行时间**：运行一个程序所花费的时间

CPU执行时时间 = CPU时钟周期数 / 主频 = ( 指令条数 × CPI ) / 主频

**MIPS**：每秒执行多少百万条指令

MIPS = 指令条数 / (执行时间 × $10^{6}$) = 主频 / (CPI × $10^{6}$)

> **描述文件大小时**，K、M、G、T 通常用 2 的幂次表示，如 1Kb= $2^{10}$b；
> **描述速率、频率时**，k、M、G、T 通常用 10 的幂次表示，如 1kb/s = $10^{3}$b/s
> 前者通常用大写 K，后者用小写 k

**字、字长、机器字长、指令字长、存储字长的区别和联系是什么?**

> 在通常所说的“某16 位或32位机器”中，16、32指的是字长，也称**机器字长**。所谓**字长**，通常是指CPU内部用于整数运算的数据通路的宽度，因此字长等于CPU内部用于整数运算的运算器位数和通用寄存器宽度，它反映了计算机处理信息的能力。字和字长的概念不同。**字**主用来表示被处理信息的单位，用来度量数据类型的宽度，如 x86 机器中将一个字定义为 16 位。
> **指令字长:**一个指令字中包含的二进制代码的位数。
> **存储字长:**一个存储单元存储的二进制代码的长度。
> 它们都必须是字节的整数倍。
> 指令字长一般取存储字长的整数倍，若指令字长等于存储字长的 2 倍，则需要 2 个访存周期来取出一条指令；若指令字长等于存储字长,则取指周期等于机器周期。

# 第二章—数据的表示和运算

正数的原反补都一样

负数反码为原码取反

负数补码为原码取反加一

移码为真值加偏移量

## 标志位生成 （OF、SF、ZF、CF）

**OF**：

- **含义**：有符号数的加减运算是否发生了溢出 *OF = 1表示溢出*

- **计算方法**：**最高位产生的进位与次高位产生的进位异或  *异或：不同为1，相同为0*

- 对无符号数的加减无意义

**SF**：

- **含义**：有符号数加减运算的正负性 *SF = 0表示正数*

- **计算方法**：最高位的本位和

- 对无符号数的加减无意义

**ZF**：

- **含义**：运算结果是否为 0       *ZF=1表示运算结果为 0*

**CF**：

- **含义**：进位/借位标志，是否发生了进位或借位  *CF = 1 表示无符号数加减法出现了进位 / 借位 / 溢出*

- 计算方法最高位产生的进位与sub进行异或   *减法sub=1，加法sub=0*

- 对有符号数的加减法无意义

## 定点数加减法

![定点数加减法运算.png](/images/计算机组成原理/定点数加减法运算.png)


## 数据的存储和排列

**大端方式**：从字节最高位到最低位顺序存储

**小端方式**：从字节最低位到最高位顺序存储

**按边界对齐和不对齐存储方式**

![](/images/计算机组成原理/存储对齐方式.png)


## 浮点数

**表示格式**：

![](C:\Users\CYT19\Desktop\计算机组成原理+4014ded3-6a9c-4b1c-b9ee-e40ba4bb9f4f\计算机组成原理+4014ded3-6a9c-4b1c-b9ee-e40ba4bb9f4f\浮点数表示格式.png)


*阶码通常用移码表示  （移码为真值加偏移量）*

- 全 0 阶码全 0 尾数：符号取决于数符，一般情况下 +0 和 -0 时等效的

- 全 1 阶码全 0 尾数： 表示正负无穷，正无穷大于所有有限数，负无穷小于所有有限数

**真值计算**：$(-1)× 数符 × 基数^{阶码} × 尾数$  *基数为隐含的，题中一般会给出，默认为 2*

### 浮点数规格化：

**左归**：尾数左移 n 位，阶码减 n

**右归**：尾数右移 n 位，阶码加 n

在 IEEE754 中尾数最高位隐含一位 1 ，计算时要留意

### IEEE754浮点数格式

![IEEE754浮点数格式.png](/images/计算机组成原理/IEEE754浮点数格式.png)

### 浮点数加减运算

小阶向大阶看起，尾数加减，计算完之后进行规格化，只有规格化之后溢出才是真溢出

# 第三章—存储系统

**存储容量**：存储字数 × 字长    *存储字数表示存储器地址空间大小，字长表示依次存取操作的数据量*

**存储速度**：数据传输速率 = 数据带宽 / 存储周期

- 存取时间：从启动到完成操作的时间，分为读入时间和写入时间

- 存取周期：进行一次完整的读写操作需要的全部时间 *包含最后的恢复时间*

- 主存带宽：又称数据传输速率，表示每秒从主存进出信息的最大数量，单位为 字/秒、字节/秒(B/s)、位/秒(b/s)

## 主存储器（RAM）

**SRAM**：静态随机存储器，使用双稳态触发器，非破坏性读出，存储速度快，集成度低，功耗大，价格昂贵，一般用于高速缓冲器

**DRAM**：动态随机存储器，使用栅极电容存储器，破坏性读出，容易集成，价格低，容量大，功耗低，比 SRAM 慢，隔一段时间需要刷新，通常取 2ms

**DRAM 刷新方式**

- **集中刷新**：利用一段固定的时间进行刷新，优点：读写时不受影响。缺点：存在死区

- **异步刷新**：2ms内每行都刷新一次，2ms / 行数 = n ms，每 n ms刷新一行

DRAM刷新对CPU时透明的，刷新单位为行，芯片内部自行生成地址

- **分散刷新**：每次读写完就刷新一行，优点：没有死区。缺点：增加了存储周期

### SRAM和DRAM的对比

![SRAM和DRAM的对比.png](/images/计算机组成原理/SRAM和DRAM的对比.png)

## 只读存储器（ROM）

1. 结构简单，位密度高

2. 具有非易失性，可靠性高

## 多模块存储器

### 单体多字存储器

存储器中只有一个存储体，每个存储单元存储 m 个字，总线宽度也为 m 个字，一行并行读出 m 个字，地址必须顺序排列并处于同一存储单元。

### 多体并行存储器

有多体模块组成，每个模块有相同的容量和存储速度，各模块都有相同的读写控制电路、地址寄存器和数据寄存器。他们既能并行工作，又能交叉工作

多体并行存储器有高位交叉编址和低位交叉编址

**高位交叉编址**

顺序存储方式，高位地址表示体号，低位地址表示为体内地址

**低位交叉编址**

低位地址为体号，高位地址为体内地址，用模运算来获得体号，

设模块字长等于数据总线宽度，模块存取一个字的存取周期为 T ，总线传送周期为 r ，实现流水线方式存取，存储器交叉模块数应大于等于$m=T{\div} r$，连续存取 m 个字需要时间为 $t=T+(m-1)\times r$

![交叉存储编址例题.png](/images/计算机组成原理/交叉存储编址例题.png)

## 主存容量的扩展

### 位扩展

扩展的是数据总线

![位扩展.png](/images/计算机组成原理/位扩展.png)

### 字扩展

扩展的是地址总线

![字扩展.png](/images/计算机组成原理/字扩展.png)

### 字位同时扩展

![字位同时扩展.png](/images/计算机组成原理/字位同时扩展.png)

### 存储芯片的地址分配和片选

**线选法**：某地址线信息为 0 ，就是选中与之对应的存储芯片。优点：不需要译码器，线路简单。缺点：地址空间不连续，

**译码片选法**：通过地址译码器产生片选信号

## 外部存储器

**磁盘存储器**

扇区是磁盘读写的最小单位

**平均存取时间**：由寻道时间，旋转延时，传输时间

**数据传输率**： r 转/秒，磁道容量 N 字节，D = r × N

**磁盘地址结构**

![磁盘地址格式.png](/images/计算机组成原理/磁盘地址格式.png)

## 高速缓冲存储器（Cache）

通常由 SRAM 组成，为了方便 Cache 与主存交换信息，Cache 和主存都被划分为相等的块，Cache 块又称为 Cache 行，每行由一些字组成，块的长度称为块长

CPU 和 Cache 之间的数据交换以字为单位

**时间局部性**：最近的未来要使用的信息可能为现在正在使用的信息

**空间局部性**：最近的未来要使用的信息可能与现在正在使用的信息在存储空间上是临近的

**命中率(CPU -> Cache)**：总命中次数为 N，访问主存的总次数为 M ，则命中率为：$H=\frac{N}{N+M} $   *命中率越接近 1 越好*

**平均访问时间(Cache和主存)**：K 为命中 Cache 的访问时间，L为未命中访问时间，1 - H 表示未命中率，平均访问时间：$T=h\times K+(1- H)\times L$

![Cache命中率.png](/images/计算机组成原理/Cache命中率.png)

### Cache和主存的映射方式

**全相联映射**：

主存块可以放在 Cache 的任意位置

**优点**：空间利用充分，命中率高；**缺点**：查找速度慢，需要对比所有标记的行

**直接映射**：

每个主存块只能放到一个特定的位置：

Cache 块号 = 主存块号 % Cache总块数

**优点**：标记对比速度快；**缺点**：空间利用不充分，命中率低

**组相联映射**：

Cache 块分为若干组，每个主存块可放到特定分组中的任意一个位置

组号 = 主存块号 % 分组数

**优点**：另外两种方式的折中，综合效果好

### Cache替换算法

*在操作系统中学习*

随机算法（RAND）

先进先出（FIFO）

近期最少使用（LRU）

### Cache写策略

#### 写命中的两种处理方法

**全写法**：

CPU 对 Cache 写命中时，必须把数据同时写入 Cache 和主存，当某一块要替换时，直接覆盖即可，

> **优点**：能随时保持主存数据的正确性
> **缺点**：增加了访问次数，降低了 Cache 的效率
> **解决方法**：通过在CPU和主存之间添加一个写缓冲，可以保证对Cache和主存的写入速度一致

**回写法**：

当 CPU 对 Cache 写命中时，只把数据写入 Cache ，当这个块被替换时，才将数据写入主存

> **优点**：减少了访存次数
> **缺点**：存在数据不一致的隐患
> **解决方法**：对每个 Cache 行设置一个修改位，1 表示被修改过

#### 写不命中的两种处理方法

**写分配**

加载主存块到 Cache 中，然后更新这个块，利用了空间局部性原理；**缺点**：每次不命中都要从主存中读取一块

**非写分配**

只写入主存，不进行调块

*非写分配法通常和全写法合用，写分配法通常和回写法合用*

## 虚拟存储器

### 页式存储器

以页为基本单位，虚拟空间与主存空间都被划分为同样大小的页，主存的页称为实页，页框，虚存的页称为虚页

虚拟地址分为两个字段：虚页号和页内地址

> **优点**：页面长度固定，页表简单，调入方便
> **缺点**：程序不可能正好是页面的整数倍，最后一页的留头无法利用而造成浪费

**页表**

包含的字段：

1. 有效位：1表示虚拟页已从外存调入内存，页表项存放该页的物理页号，0表示没有调入主存，页表项可以存放该页的磁盘地址

2. 脏位：修改位，表示页面是否被修改过，采用回写法策略

3. 引用位：使用位，配合替换策略进行使用

**快表（TLB）**

采用全相联或组相联映射，快表与页表的关系就像是内存和 Cache 的关系

**地址变换过程**

先将地址虚拟地址转换为主存物理地址，页表地址寄存器存放进程的页表首地址，然后根据虚拟地址的虚拟页号找到对应的页表项，若装入位为 1，则取出物理页号，和虚拟地址的页内地址拼接，形成实际物理地址

![地址变换过程.png](/images/计算机组成原理/地址变换过程.png)

### 段式虚拟存储器

**段**是按照程序的逻辑结构划分，每个段的**长度因程序而异**，**虚拟地址**分为两个部分，段号和段内地址，虚拟地址到实际地址的**变换由段表来实现**。**段表**是程序逻辑段和在主存中存放位置的对照表。**段表记录**包括段号、装入位、段起点、段长等信息。已调入主存时，从段表读出在主存的起始地址，与段内地址（偏移量）相加得到对应的主存实地址。

> **优点**：段的分界与程序的自然分界相对应，具有逻辑独立性，易于编译、管理、修改和保护
> **缺点**：段的长度可变，不好分匹配空间，容易留下碎片

虚拟存储器和 Cache 的比较

1.相同之处

1. 最终目标都是为了提高系统性能，两者都有容量、速度、价格的梯度

2. 都把数据划分为小信息块，并作为基本的传递单位，虚存系统的信息块更大

3. 都有地址的映射、替换算法、更新策略等问题

4. 依据程序的局部性原理应用“快速缓存的思想”，将活跃的数据放在相对高速的部件中

2.不同之处

1. Cache主要解决系统速度，而虚拟存储器却是为了解决主存容量

2. Cache全由硬件实现，是硬件存储器，对所有程序员透明；而虚拟存储器由OS和硬件共同实现，是逻辑上的存储器，对系统程序员不透明，但对应用程序员透明

3. 对于不命中性能影响，虚拟存储器系统不命中时对系统性能影响更大

4. CPU与Cache和主存都建立了直接访问的通路，而辅存与CPU没有直接通路。也就是说在Cache不命中时主存能和CPU直接通信，同时将数据调入Cache；而虚拟存储器系统不命中时，只能先由硬盘调入主存，而不能直接和CPU通信。

**存储周期和存取时间有什么区别？**

> 存取时间仅为完成一次操作的时间，存取周期不仅包含操作时间，而且包含操作后线路的恢复时间
> 存储周期 = 存取时间 + 恢复时间

**存储周期就是存取周期 ？**

> 不是
> **存取时间**是执行一次都读操作或写操作的时间，分为读出时间和写入时间
> **存储周期**包含存取时间和恢复时间，是指存储器进行连续两次独立的读或写操作所需的最小时间间隔
> 一般储存周期大于存取时间

# 第四章—指令系统

## 指令格式

指令有操作码字段和地址码字段组成

> **操作码**：指出执行什么性质的操作以及具有什么功能
> **地址码**：给出被操作数据的地址，

指令长度是指一条指令中所包含的二进制代码的位数，指令字长取决于操作码的长度、操作数地址码的长度和操作数地址的个数

**定长操作码指令**：对于简化计算机硬件设计，提高指令译码和识别速度有利

**扩展操作码指令**：采取可变长的操作码，操作码位数随地址码位数的减少而增加

**转移指令**：

| 无条件转移 | 条件转移 | 调用 | 返回 | 陷阱 |
| ---------- | -------- | ---- | ---- | ---- |
| JMP        | BRANCH   | CALL | RET  | TRAP |

设地址长度为 n ，上一层留出 m 种状态，下一层可扩展出$m\times2^{n}$种状态

## 寻址方式

分为指令寻址和数据寻址

### 指令寻址

**定义**：寻找下一条将要执行的指令；指令寻址有顺序寻址和跳跃寻址，**顺序寻址**：通过程序计数器 PC 加一（ 1 个指令字长），自动形成下一条指令的地址；**跳跃寻址**：通过转移类指令实现，跳跃是指下条指令的地址不由程序计数器 PC 自动给出，由本条指令给出下条指令地址的计算方式。而是否跳跃可能受状态寄存器和操作数的控制，跳跃的地址分为绝对地址和相对地址，跳跃的结果是当前指令修改 PC 值，所以下一条指令仍是通过 PC 给出。

### 数据寻址

**定义**：寻找本条指令的数据地址称为数据寻址。数据寻址的方式比较多，为区别各种格式，通常在指令字中设一个字段，用来指明属于那种寻址方式。指令的格式如下

![数据寻址指令格式.png](/images/计算机组成原理/数据寻址指令格式.png)



#### 常见的数据寻址方式

1. **隐含寻址**： 在指令中隐含操作数的地址，例如单地址指令的格式，仅指出第一操作数的地址，规定累加器（ACC）为第二地址 **优点**：利于缩短指令字长；**缺点**：增加存储操作数或隐含地址的硬件

2. **立即（数）寻址**： 指出的是操作数本身，用补码表示 **优点**：执行阶段不访问主存，指令执行时间最短；**缺点**：操作数的位数限制了立即数的范围

3. **直接寻址**： 指令中的形式地址是操作数的真实地址 **优点**：简单，指令在执行阶段进访问一次主存，不需要计算操作数的地址；**缺点**：操作数的位数决定了该指令操作数的寻址范围，操作数的地址不易修改

4. **间接寻址**： 给出的不是操作数的真正地址，而是操作数地址的地址，间接寻址可以是一次间接寻址，还可以是多次间接寻址 **优点**：可扩大寻址范围；**缺点**：执行阶段要多次访存，一次间接寻址要两次访存

5. **寄存器寻址**： 在指令字中直接给出操作数所在寄存器的寄存器编号 **优点**：执行阶段不访问主存，只访问寄存器，执行速度快，支持向量/矩阵运算；**缺点**：寄存器价格昂贵，计算机中的寄存器个数有限

6. **寄存器间接寻址**： 在寄存器中给出的不是一个操作数，而是操作数所在主存单元的地址 **优点**：比一般间接寻址速度快；**缺点**：执行阶段需要访问主存

7. **相对寻址**： 用 PC 的内容加上指令格式中的形式地址，得到操作数的有效地址，形式地址可以为正或负，用补码表示 *以 PC 当前指定的位置作为起点* **优点**：操作数的地址不是固定的，与指令地址总是相差一个固定的值，便于程序浮动，广泛用于转移指令。 *如果执行的是转移指令(假如占 2B)，取出指令后 PC 中的值会增加 2，执行完该指令后会再增加一个指令的长度*

8. **基址寻址**： 将 CPU 中的基址寄存器( BR )的内容加上指令格式中的形式地址形成操作数的有效地址 *以程序的起始地址作为起点* **优点**：可扩大寻址范围，利于多道程序设计；**缺点**：偏移量（形式地址）的位数短 *基址寄存器是面向操作系统的，内容由操作系统或管理程序确定，在程序执行期间内容不可变*

9. **变址寻址**：

   将指令字中的形式地址加上变址寄存器的内容形成有效地址 *由程序员指定从哪里开始* **优点**：可扩大寻址范围，足以表示整个存储空间 *变址寄存器是面向用户的，在程序执行过程中，其内容可以被用户改变*

10. **堆栈寻址**： 堆栈是存储器中一块特定的、按先进先出原则管理的存储区，存储区中读写单元的地址用堆栈指针给出

**指令寻址方式的特点和适用情况**

1. 立即寻址操作数获取便捷，通常用于给寄存器赋初值。

2. 直接寻址相对于立即寻址，缩短了指令长度。

3. 间接寻址扩大了寻址范围，便于编制程序，易于完成子程序返回。

4. 寄存器寻址的指令字较短，指令执行速度较快。

5. 寄存器间接寻址扩大了寻址范围。

6. 基址寻址扩大了操作数寻址范围，适用于多道程序设计，常用于为程序或数据分配存储空间。

7. 变址寻址主要用于处理数组问题，适合编制循环程序。

8. 相对寻址用于控制程序的执行顺序、转移等。

9. 基址寻址和变址寻址的区别:两种方式有效地址的形成都是寄存器内容+偏移地址，但是在基址寻址中，程序员操作的是偏移地址，基址寄存器的内容由操作系统控制，在执行过程中是动态调整的;而在变址寻址中，程序员操作的是变址寄存器，偏移地址是固定不变的。

## 机器级代码表示

**参数说明**

中括号 " [ ] " 表示地址，地址后面可以加减偏移量

**dword**：双字；**word**：单字；**byte**：字节；

**数据传送指令**

- **mov** <>,<>; 将第二个操作数复制到第一个操作数

- **push** <>; 将操作数压入内存的栈，*通常用于函数调用，ESP 是栈顶，压栈前先将 ESP 减 4*

- **pop** <>; 出栈操作，*出栈前先将 ESP 指向的内容出栈，再将 ESP 的值加 4*

**算数和逻辑运算指令**

- **add/sub** <>,<>; 将两个操作数相加，结果保存到第一个操作数中，sub 为相减

- **inc/dec** <>; 将操作数自加

- **imul** <>,<>,<>; 乘法指令,第一个必须为寄存器，操作数可以为三个或两个

- **idiv** <>; 带符号整数除法，只有一个操作数，被除数为隐含的

- **and/or/xor** <>,<>; 逻辑与、或、非，结果放在第一个操作数中

- **not** <>; 取反，将操作数中的每一位取反

- **neg** <>; 取负数

- **shl/shr** <>,<>; 逻辑位移，shl 为左移，shr 为右移

**流程控制指令**

x86 处理器维持着一个指示当前执行指令的指令指针 IP ，当一条指令执行后自动指向下一条指令

通过给某条语句前加一个标记，再通过跳转指令跳转到这个位置

- **jmp** <lable>; 转移指令，控制 IP 跳转到指定的 lable 标记

- **j** *condition* <>; 条件转移指令，condition为可选参数 je <>; 相等时跳转 jne <>; 不相等时跳转 jz <>; 左后结果为 0 跳转 jg <>; 大于时跳转 jge <>; 大于或相等时跳转 jl <>; 小于时跳转 jle <>; 小于或等于时跳转

- **cmp/test** <>,<>; 比较两个操作数的值，test进行逐位与运算，不保存操作结果，仅根据运算结果设置 CPU 状态字中的条件码

- **call/ret** <>; 实现子程序的调用和返回

## CISC(复杂指令系统)和(精简指令系统)RISC

### CISC的主要特点

1. 指令系统复杂庞大，指令数目- .般为200条以上。

2. 指令的长度不固定，指令格式多，寻址方式多。

3. 可以访存的指令不受限制。

4. 各种指令使用频度相差很大。

5. 各种指令执行时间相差很大，大多数指令需多个时钟周期才能完成。

6. 控制器大多数采用微程序控制。有些指令非常复杂，以至于无法采用硬连线控制。

7. 难以用优化编译生成高效的目标代码程序。

### CISC的主要特点

1. 选取使用频率最高的一些简单指令，复杂指令的功能由简单指令的组合来实现。

2. 指令长度固定，指令格式种类少，寻址方式种类少。

3. 只有Load/Store (取数/存数)指令访存，其余指令的操作都在寄存器之间进行。

4. CPU中通用寄存器的数量相当多。

5. RISC一定采用指令流水线技术，大部分指令在一个时钟周期内完成。

6. 以硬布线控制为主，不用或少用微程序控制。

7. 特别重视编译优化工作，以减少程序执行时间。

### CISC和RISC的对比

|                  | CISC                                 | RISC                                 |
| ---------------- | ------------------------------------ | ------------------------------------ |
| 指令系统         | 复杂，庞大                           | 简单，精简                           |
| 指令数目         | 一般大于 200 条                      | 一般小于 100 条                      |
| 指令字长         | 不固定                               | 定长                                 |
| 可访存指令       | 不加限制                             | 只有 Load / Store 指令               |
| 各种指令执行时间 | 相差较大                             | 绝大多数在一个周期内完成             |
| 各种指令使用频度 | 相差很大                             | 都比较常用                           |
| 通用寄存器数量   | 较少                                 | 多                                   |
| 目标代码         | 难以用优化编译生成高效的目标代码程序 | 采用优化的编译程序，生成代码较为高级 |
| 控制方式         | 绝大多数以微程序控制                 | 绝大多数为组合逻辑控制               |
| 指令流水线       | 可以通过一定方式实现                 | 必须实现                             |



