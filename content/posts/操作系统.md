+++
title = '操作系统'
date = 2024-10-01T22:48:12+08:00
categories =  ["计算机基础","学习笔记"] 
tags = ["计算机基础","学习笔记","操作系统"]

+++

# 第一章

## 基本概念

**特权指令**：I/O 指令、置中断、存取用于内存保护的寄存器，送程序状态字到程序状态寄存器

**非特权指令**：允许用户直接使用的指令，不能直接访问程序中的软硬件资源，仅限于访问用户的地址空间

特权指令运行在核心态，非特权指令运行在核心态

**中断和异常**：

**中断**：也称为外中断，只来自 CPU 执行指令的外部事件，通常用于信息输入/输出，如 I/O 结束中断，时钟中断
中断可以分为可屏蔽中断和不可屏蔽中断，可屏蔽中断可以实现多重中断，从而使中断处理更加灵活，不可屏蔽中断，通常是紧急的硬件故障，如电源掉电，

**异常**：也称为内中断，是指来自内 CPU 执行指令内部的事件，如程序的非法操作码、地址越界、运算溢出、虚存系统的却也及专门的陷入指令等引起的事件，异常不能被屏蔽，发生之后必须立即处理，异常分为故障、自陷、终止。故障通常由指令执行引起的异常，如非法操作码、缺页故障、除数为 0 ，运算溢出等。自陷时一种事先安排的异常事件，用于在用户态下调用操作系统内核程序，如条件陷阱指令。终止时出现了使 CPU 无法继续执行的硬件故障，如控制器出错、存储器校验错等。故障异常和自陷异常输入软件中断，终止异常和外部中断属于硬件中断，

**系统调用**：是指用户在程序中调用操作系统所提供的一些子功能，系统调用可以视为特殊的公共子程序

**由用户态转向核心态的例子**

1. 用户程序发生系统调用

2. 发生一次中断

3. 用户程序中产生了一个错误状态

4. 用户程序中企图执行一个特权指令

5. 从核心态转向用户态由一条指令实现，这条指令也是特权指令，一般是中断返回指令

*从用户态转向核心态用到的访管指令为非特权指令*

## 操作系统的结构

**分层法**：

> 最底层为硬件，最高层为用户接口，每层只能调用相邻层
> **优点**：便于系统调试和验证，简化了系统的设计和实现，易扩充和易维护
> **缺点**：合理定义各层功能困难，效率差

**模块化**：

> 按功能将操作系统划分为具有一定独立性的模块
> **优点**：提高操作系统设计的正确性、可理解性和可维护性。增加了操作系统的可适应性。加快了开发过程
> **缺点**：接口规定很难满足对接口的实际需求，无法找到一个可靠的决定顺序

**宏内核**

> 也称为单内核或大内核，是将系统的主要功能模块都作为一个紧密联系的整体

**微内核**

> 将内核中最基本的功能保留在内核，将那些不需要在核心态执行的功能移到用户态
> **基本功能**：进程(线程)管理、低级存储器管理、中断和陷入处理
> **特点**：易扩展和灵活、安全可靠、可移植、分布式计算、基于客户/服务器模式

**操作系统引导**：

激活CPU，启动BIOS开始硬件自检、硬件错误会发出蜂鸣、加载带有操作系统的硬盘、加载主引导记录MBR、扫描硬件分区表、加载分区引导记录PBR、加载启动管理器、加载操作系统、

# 第二章—进程与线程

**为什么引入进程？**

更好的描述和控制程序的并发执行，实现操作系统的并发性和共享性

​       当操作系统欲调度某进程运行时，要从该进程的 PCB 中查出其现行状态及优先级；在调度到某进程后，要根据其PCB中所保存的处理机状态信息，设置该进程恢复运行的现场，并根据其PCB中的程序和数据的内存始址，找到其程序和数据；进程在运行过程中，当需要和与之合作的进程实现同步、通信或访问文件时，也需要访问PCB；当进程由于某种原因而暂停运行时，又需将其断点的处理机环境保存在PCB中。

**进程**

> 是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位
> 进程是程序的一次执行过程，是一个程序及数据在处理机上顺序执行是所发生的活动，是具有独立功能的程序在一个数据集合上运行的过程

**进程实体(又称为进程影像)**由程序段、相关数据和 PCB(进程控制块) 组成，所谓创建进程，实质上是创建进程中的 PCB；而撤销进程是撤销进程的 PCB ，进程映像是静态的，进程是动态的。PCB 是进程存在的唯一标识

**进程的特征**：动态性(基本特征)、并发性(重要特征)、独立性、异步性

## 进程的状态与转换

**运行态**：正在处理机上运行

**就绪态**：已经获得执行需要的一切资源，就差处理机

**阻塞态**：正在等待某事件而暂停运行

**创建态**：正在被创建

**结束态**：正在系统中消失

**进程组织方式**：在一个系统中，同行存在着许多进程的 PCB (进程控制块)，他们会处于各种状态，方便进程的调度和管理，将 PCB 按照适当的方法组织起来，常用的组织方式有链接方式和索引方式，**链接方式**指将同一状态的 PCB 连接成一个队列，**索引方式**指将同一状态的 PCB 组织在一个索引表中

## 进程的阻塞和唤醒

当进程期待的事件未发生时进程便调用阻塞原语 Block ，阻塞是进程的主动行为，

当阻塞的进程期待的事件发生时进程便调用唤醒原语 Wakeup，将进程从等待队列中移除，放入就绪队列

Block 和 Wakeup 必须成对使用

## 进程通讯

### 共享存储

通过对共享空间进行读/写操作实现进程之间的信息交换。对共享空间进行读写操作时，需要借助同步互斥工具

共享存储又分为两种：低级方式的共享是基于数据结构的共享;高级方式的共享则是基于存储区的共享。操作系统只负责为通信进程提供可共享使用的存储空间和同步互斥工具，而数据交换则由用户自己安排读/写指令完成。

**注意**： *进程空间一般都是独立的，进程运行期间一般不能访问其他进程的空间，想让两个进程共享空间，必须通过特殊的系统调用实现，而进程内的线程是自然共享进程空间的。*

### 消息传递

数据交换以格式化的消息为单位，进程通过系统提供的发送消息和接收消息两个原语进行数据交换

消息传递有两种方式，**直接通信**发送进程直接放消息发送给接收进程，并将他挂在接收进程的消息缓冲队列上，接收进程从消息缓冲队列中获取消息，**间接通信**发送进程把消息发送到某个中间实体，接受进程从中间实体取得消息

### 管道通信

是消息传递的一种特殊方式，“管道” 就是链接一个读进程和一个写进程实现他们之间通讯的一个共享文件——pipe文件
写进程以字符流的形式往管道文件中写入数据，读进程以字符流形式从管道文件读出数据，由此完成管道通讯
管道机制必须提供以下三方面的协调能力：互斥、同步、确定对方存在

数据在管道中遵守先进先出原则，管道只能采用半双工通信，父子进程实现通信，需要定义两个管道

## 线程和多线程模型

引入线程的目的是减少程序在并发执行时所付出的时空开销，提高操作系统的并发性能，进程提高了资源利用率和系统吞吐量

### 线程基本感念：

> 线程最直接的理解就是“轻量级进程”，它是一个基本的CPU执行单元，也是程序执行流的最小单元，由线程ID、程序计数器、寄存器集合和堆栈组成。线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源，但它可与同属一个进程的其他线程共享进程所拥有的全部资源。一个线程可以创建和撤销另一个线程，同一进程中的多个线程之间可以并发执行。由于线程之间的相互制约，致使线程在运行中呈现出间断性。线程也有就绪、阻塞和运行三种基本状态。

引入线程后，进程只作为除CPU外的系统资源的分配单元，而线程则最为处理机的分配单元

### 线程和进程的比较

1. 调度：同一进程中线程切换不会引起进程切换，不同进程中线程切换会引起进程切换

2. 并发：不同进程的线程可以并发，同一进程的线程也可以并发

3. 拥有资源：进程是系统中拥有资源的基本单位，进程不拥有系统资源，但是可以访问所属进程的系统资源

4. 独立性：进程有用独立的地址空间和资源，除了共享全局变量，某进程中的线程对其他进程是不可见的

5. 系统开销，创建和撤销进程时，需要为之分配或收回进程控制块和其他资源，进程切换设计进程上下文切换，而线程切换只需要保存和设置少量寄存器内容，同一进程下的线程进行通信无需操作系统干预

6. 支持多处理机系统，可以将进程中的多个线程分配到多个处理机上执行

### 线程的实现方式

有两种实现方式：用户级线程和内核级线程

#### 用户级线程

由应用程序在用户空间内完成，

**优点**：进程切换不需要转换到内核态。调度算法可以是进程专用的。线程的实现与操作系统平台无关，对线程管理的代码属于用户程序的一部分

**缺点**：系统调用的阻塞问题，当线程执行一个系统调用时，不仅该线程被阻塞，而且进程内的所有线程都被阻塞。不能发挥多处理机的优势，内核每次分配给一个进程的仅有一个CPU，因此进程中仅有一个线程能执行。

#### 内核级线程

在内核的支持下运行，线程管理的工作都在内核空间内实现

**优点**：能发挥多处理机的优势，内核能同时调度同一进程中的多个线程并行执行。如果进程中的一个线程被阻塞，内核可以调度该进程中的其他线程占用处理机，也可运行其他进程中的线程。内核支持线程具有很小的数据结构和堆栈，线程切换比较快、开销小。内核本身也可采用多线程技术，可以提高系统的执行速度和效率。

**缺点**：同一进程中的线程切换，需要从用户态转到核心态进行，系统开销大，这是因为用户进程的线程在用户态运行，而线程调度和管理是在内核实现的。

### 多线程模型

**多对一模型**：将多个用户级线程映射到一个内核级线程。**优点**：线程管理是在用户空间进行的，效率高。**缺点**：如果一个线程在访问内核时发生阻塞，则整个进程都会被阻塞

**一对一模型**：将每个用户级线程映射到一个内核级线程上，**优点**：并发能力强。**缺点**：开销大

**多对多模型**：将多个用户级线程映射到少量的内核级线程上，内核线程数量不能大于用户线程数量。克服了上面两种缺点，融合了上面两种的优点

## 处理机调度

**高级调度(作业调度)**

从外存上处于后背队列的作业中选取一个或多个，给他们分配内存、输入输出设备等必要的资源并建立相应的进程。内存与辅存之间的调度，对于每个作业只调入一次、调出一次

**中级调度(内存调度)**

存储器管理中的对换功能

**低级调度(进程调度)**

从就绪队列中选取一个进程分配处理器

调度程序(调度器)：通常由三部分组成：排队器、分派器、上下文切换器

**调度的时机、切换与过程**

在处理中断、进程在操作系统内核临界区中、其他需要完全屏蔽中断的原子操作过程中不能进行进程的调度与切换

**应该进行调度和切换的情况**

发生引起调度条件且当前进程无法继续进行下去时，非剥夺调度

中断处理结束或自陷处理结束后，返回被中断进程的用户态程序执行现场前，若置上请求调度标志，即可马上进行程序调度与切换，剥夺方式调度

### 闲逛程序

如果系统中没有就绪进程，就会调度闲逛进程（idle）运行，如果没有其他进程就绪，该进程会一直运行，并在执行过程中测试中断，该程序优先级最低，闲逛进程不需要CPU之外的资源，不会被阻塞

### 线程调度

### 调度算法

**先来先服务（FCFS）**：从就绪队列中选择最先进入该队列的进程，直到运行完成或阻塞才会切换下一个进程，非抢占式调度

**特点**：算法简单，效率高；对长作业有利，对短作业不利；有利于CPU繁忙型作业，不利于 I/O 繁忙型作业

**短作业优先（SJF）**：从就绪队列中选择估计运行事件最短的进程，直到运行完成或阻塞才会切换下一个进程，非抢占式调度

> ***进程优先级***
> **进程优先级设置参照原则**

    1. 系统进程 ＞ 用户进程
    
    2. 交互性进程 ＞ 非交互进程
    
    3. I/O型进程 ＞ 计算型进程

根据进程创建后其优先级是否可以改变，可以将进程优先级分为
**静态优先级**：在创建进程时确定，在进程的整个运行期间保持不变
**动态优先级**：根据进程情况的变化动态调整优先级

**饥饿现象**：高优先级需求的持续涌入耗尽了OS中的资源，导致低优先级进程无法获得处理器或资源

**特点**：对长作业不利，未考虑作业的紧迫程度，作业的长度使根据用户所提供的估计执行时间而定的；平均等待时间、平均周转时间最少

1. **先来先服务（FCFS）**：从就绪队列中选择最先进入该队列的进程，直到运行完成或阻塞才会切换下一个进程，非抢占式调度

   **特点**：算法简单，效率高；对长作业有利，对短作业不利；有利于CPU繁忙型作业，不利于 I/O 繁忙型作业

2. **短作业优先（SJF）**：从就绪队列中选择估计运行事件最短的进程，直到运行完成或阻塞才会切换下一个进程，非抢占式调度

   **特点**：对长作业不利，未考虑作业的紧迫程度，作业的长度使根据用户所提供的估计执行时间而定的；平均等待时间、平均周转时间最少

3. **优先级调度**：从就绪队列中选择优先级最高的，按能否抢占正在执行的进程，可以分为非抢占式和抢占式，主要区别为在进程运行时，更高级别的进程进入就绪队列，是否可以立刻分配到处理器

4. **高相应比优先调度**：进行作业调度时，先计算后备作业队列中每个作业的相应比，从中选出相应比最高的作业投入运行，该算法可以克服饥饿现象
   相应比 = ( 等待时间 + 要求服务时间 ) / 要求服务时间

5. **时间片轮转调度**：适用于分时系统，在 FCFS 的基础上为每个作业分配时间片，时间片结束强行切换下一个进程，时间片的长短又系统的响应时间、就绪队列中的进程数目和系统的处理能力

6. **多级队列调度算法**：设置多个就绪队列，将不同类型的进程分配到不同的就绪队列，每个队列实施不同的调度算法

7. **多级反馈队列调度算法**：融合了时间片轮转调度和优先级调度
   实现思想：
   1、创建多个就绪队列，一级队列优先级最高，依次递减
   2、优先级越高的队列中，每个进程的时间片就越小
   3、每个队列都采用 FCFS 算法，如果一个进程在一个时间片结束时未完成，就将其转到下一级队列的末尾，新加入的进程在一级队列
   4、当第一级队列为空时，才调度二级队列中的进程运行

### 进程切换

**上下文切换过程**：

> *上下文切换是在内核的支持下完成的*

1. 挂起进程，保存 CPU 上下文，和程序计数器、相关寄存器

2. 更新 PCB 信息

3. 将 PCB 移入相应的队列

4. 选择新的进程，并更新该进程的 PCB

5. 跳转到 PCB 中程序计数器所指向的位置

6. 恢复处理器上下文

**模式切换**：用户态和内核态之间的切换称为模式切换

## 同步和互斥

同步机制应遵循的准则：

1. **空闲让进**：临界区空闲，允许一个请求进入

2. **忙则等待**：已经有进程在临界区时，其他请求必须等待

3. **有限等待**：保证等待的请求在有限时间内解决

4. **让权等待**：进程不能立即进入临界区，需立刻释放处理器

信号量实现前驱关系

![信号量实现前驱关系.png](/images/操作系统/信号量实现前驱关系.png)

### 经典同步问题

生产者-消费者问题

读者-写者问题

哲学家进餐问题

吸烟者问题

## 死锁

多个进程因竞争资源而造成的一种僵局（互相等待），若无外力左右，这些进程都将无法向前推进

**死锁产生的原因**

1. 系统资源的竞争

2. 进程推进顺序不当

**死锁产生的必要条件**

1. 互斥条件

2. 不剥夺条件（只能是主动释放）

3. 请求并保持条件

4. 循环等待条件

**死锁预防**

防止死锁的发生只需破坏死锁产生的 4 个必要条件之一即可

1. 破坏互斥条件：允许系统资源可以共享使用
   缺点：可行性低，因为打印机之类的只能互斥使用

2. 破坏不剥夺条件：一个进程请求新的资源得不到满足时，释放所有已占用的资源
   缺点：实现复杂，增加系统开销，降低系统吞吐量

3. 破坏请求并保持条件：运行前一次申请完所需要的全部资源
   缺点：系统资源被严重浪费，会导致“饥饿”现象

4. 破坏循环等待条件：采用顺序资源分配法，给资源编号，进程必须按编号递增顺序请求资源，同类资源一次申请完
   缺点：编号必须相对稳定，给编程带来麻烦

**死锁避免**

在资源动态分配过程中，防止系统进入不安全状态，限制条件较弱，可以获得较好的系统性能

### 银行家算法

**死锁解除**

1. 资源剥夺：挂起某些死锁进程，并抢占它的资源，但要防止被挂起的进程长时间得不到资源

2. 撤销进程，强制撤销死锁进程，并剥夺其资源

3. 进程回退：让一个进程回退到可以避免死锁的地步，回退时自愿释放资源而不是剥夺

# 第三章—内存管理

固定分区会产生内部碎片，动态分区会产生外部碎片

## 程序的链接与装入

**编译**：由编译程序将用户源代码编译成若干目标模块。
**链接**：由链接程序将编译后形成的一组目标模块及它们所需的库函数链接在一起，形成一个完整的装入模块。
**装入**：由装入程序将装入模块装入内存运行

### 程序的链接方式

**静态链接**（非重点）
在程序运行之前，先将各目标模块及它们所需的库函数链接成一个完整的装配模块，以后不再拆开。

**装入时动态链接**
将用户源程序编译后所得到的一组目标模块，在装入内存时，**采用边装入边链接的方式**。**优点**是便于**修改**和**更新**，便于实现对目标模块的**共享**。

**运行时动态链接**
在程序执行中需要该目标模块时才进行链接。凡在执行过程中未被用到的目标模块，都不会被调入内存和被链接到装入模块上。其**优点**是能加快程序的装入过程，还可节省大量的内存空间。

### 内存的装入方式

**绝对装入**
按照装入模块中的地址，将程序和数据装入内存。绝对装入方式只适用于单道程序环境。

**可重定位装入**
根据内存的当前情况，将装入模块装入内存的适当位置。在装入时对目标程序中指令和数据地址的修改过程称为重定位，又因为地址变换通常是在进程装入时一次完成的，故称为**静态重定位**。当一个作业装入内存时，必须给它分配要求的全部内存空间，若没有足够的内存，则无法装入。此外，作业一旦进入内存，整个运行期间就不能在内存中移动，也不能再申请内存空间。

**动态运行时装入**
也称**动态重定位**。程序在内存中若发生移动，则需要采用动态的装入方式。装入程序把装入模块装入内存后，并不立即把装入模块中的相对地址转换为绝对地址，而是把这种地址转换推迟到程序真正要执行时才进行。因此，装入内存后的所有地址均为相对地址。这种方式需要一个重定位寄存器的支持

对于32位系统，逻辑地址空间的范围为 0 ~ $2^{32}-1$

### 进程的内存映像

一个进程的内存映像一般有几个要素:

- **代码段**：即程序的二进制代码，代码段是只读的，可以被多个进程共享。

- **数据段**：即程序运行时加工处理的对象，包括全局变量和静态变量。

- **进程控制块(PCB)**：存放在系统区。操作系统通过PCB来控制和管理进程。

- **堆**：用来存放动态分配的变量。通过调用malloc 函数动态地向高地址分配空间。

- **栈**：用来实现函数调用。从用户空间的最大地址往低地址方向增长。

### 内存保护

**常用的两种方法**

1. 在CPU中设置一对上、下限寄存器，判断有无越界

2. 采用重定位寄存器和界地址寄存器：重定位寄存器含最小的物理地址值，界地址寄存器含逻辑地址的最大值

### 连续分配管理方式—动态分区分配

### **动态分区分配策略**

**首次适应算法**：空闲分区以地址递增顺序链接。分配时找到大小能满足要求的第一个空闲分区分配给作业。**缺点**低地址部分容易产生很多小的空闲分区

**临近适应算法**：有首次适应算法演变而成，不同之处，从上次查找结束的位置开始继续查找。容易导致内存空间的尾部分裂成小碎片

**最佳适应算法**：按容量递增顺序链接，找到第一个能满足要求且最小的空闲分区分配给作业。性能很差，产生最多的外部碎片

**最坏适应算法**：按容量递减顺序链接，找到第一个能满足要求的最大分区。会很快的导致没有可用的大内存块

### 分页存储管理

分页管理不会产生外部碎片，每个进程平均只产生半个块大小的内部碎片（业内碎片）

#### 基本地址变换

![分页管理中的地址变换.png](/images/操作系统/分页管理中的地址变换.png)

#### 快表地址变换

![加入快表的分页地址变换.png](/images/操作系统/加入快表的分页地址变换.png)

## 虚拟内存

**时间局部性**：某条指令一 旦执行，不久后该指令可能再次执行

**空间局部性**：访问了某个存储单元，在不久后，其附近的存储单元也将被访问

时间局部性通过将近来使用的指令和数据保存到高速缓存中，并使用高速缓存的层次结构实现。空间局部性通常使用较大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现。虚拟内存技术实际上建立了“内存一外存”的两级存储器结构，利用局部性原理实现高速缓存。

### 页框分配

#### 内存分配策略

**固定分配局部置换**：为每个进程分配一定数目的物理块，在进程运行期间都不改变。所谓局部置换，是指如果进程在运行中发生缺页，则只能从分配给该进程在内存的页面中选出一页换出

**可变分配全局置换**：先为每个进程分配--定数目的物理块，在进程运行期间可根据情况适当地增加或减少。所谓全局置换，是指如果进程在运行中发生缺页，系统从空闲物理块队列中取出一块分配给该进程，并将所缺页调入。比固定分配局部置换更灵活，可动态增加进程的物理块，但会盲目地给进程增加物理块

**可变分配局部置换**：为每个进程分配一定数目的物理块，发生缺页时，只允许从该进程在内存的页面中选出一页换出，不会影响其他进程的运行。若频繁地发生缺页中断，则系统再为该进程分配若干物理块，直至该进程的缺页率趋于适当程度

#### 物理块调入算法

1. **平均分配算法**：将系统中所有可供分配的物理块平均分配给各个进程。

2. **按比例分配算法**：根据进程的大小按比例分配物理块。

3. **优先权分配算法**：为重要和紧迫的进程分配较多的物理块。

#### 调入页面过程

当进程所访问的页面不在内存中时(存在位为0)，便向CPU发出缺页中断，中断响应后便转入缺页中断处理程序。该程序通过查找页表得到该页的物理块，此时如果内存未满，则启动磁盘I/O，将所缺页调入内存，并修改页表。如果内存已满，则先按某种置换算法从内存中选出一页准备换出；如果该页未被修改过(修改位为0)，则无须将该页写回磁盘；但是，如果该页已被，修改(修改位为1),则必须将该页写回磁盘，然后将所缺页调入内存，并修改页表中的相应表项，置其存在位为1。调入完成后，进程就可利用修改后的页表形成所要访问数据的内存地址。

### 页面置换算法

**最佳置换算法（OPT）**：淘汰页面是以后永不使用的页面，或是在最长时间内不再被访问的页面

**最近最久未使用置换算法（LRU）**：选择最近最长时间未访问过的页面予以淘汰，FIFO算法基于队列实现，

**先进先出页面置换算法（FIFO）**：优先淘汰最早进入内存的页面，即淘汰在内存中驻留时间最久的页面，基于队列实现

**CLOCK置换算法**：

至少扫描两轮

![简单CLOCK页面置换算法.png](/images/操作系统/简单CLOCK页面置换算法.png)

改进型CLOCK置换算法

用修改位 A 和访问位 M 标记页面，根据一定的优先级来找到可以被替换出页面

- **1类A=0,M=0:**最近未被访问且未被修改，是最佳淘汰页。

- **2类A=0,M=1:**最近未被访问，但已被修改，不是很好的淘汰页。

- **3类A=1,M=0:**最近已被访问，但未被修改，可能再被访问。

- **4类A=1,M=1:**最近已被访问且已被修改，可能再被访问。

**执行过程**

1. 从指针的当前位置开始，扫描循环队列，寻找4=0且M=0的1类页面，将遇到的第一个1类页面作为选中的淘汰页。在第一次扫描期间不改变访问位A。

2. 若第 1 步失败，则进行第二轮扫描，寻找4=0且M=1的2类页面。将遇到的第一个2类页面作为淘汰页。在第二轮扫描期间，将所有扫描过的页面的访问位都置0。

3. 若第 2 步也失败，则将指针返回到开始的位置，并将所有帧的访问位复0。重复第 1 步，并且若有必要，重复第2)步，此时一定能找到被淘汰的页。

### 抖动和工作集

**抖动**：刚刚换出的页面马上又要换入主存，刚刚换入的页面马上又要换出主存

**发生抖动的原因**：系统中同时运行的进程太多，由此分配给每个进程的物理块太少，不能满足进程正常运行的基本要求，致使每个进程在运行时频繁地出现缺页，必须请求系统将所缺页面调入内存。

**工作集**：在某段时间间隔内，进程要访问的页面集合。

![定点数加减法运算.png](/images/操作系统/定点数加减法运算.png)

假设系统为该进程设定的工作集窗口大小4为5，则在 t1 时刻，进程的工作集为{2, 3, 5}，在 t2 时刻，进程的工作集为{1,2,3, 4}。

### 内存映射文件

内与虚拟内存有些相似,将磁盘文件的全部或部分内容与进程虚拟地址空间的某个区域建立映射关系，便可以直接访问被映射的文件，而不必执行文件I/O操作，也无须对文件内容进行缓存处理。适合用来管理大尺寸文件。

### 地址翻译考不考？

# 第四章—文件管理

**文件控制块**

文件控制块(FCB) 是用来存放控制文件需要的各种信息的数据结构，以实现“按名存取”。FCB的有序集合称为文件目录，一个FCB就是一一个文件目录项。

FCB主要包含的信息：

- **基本信息**：如文件名、文件的物理位置、文件的逻辑结构、文件的物理结构等。

- **存取控制信息**：包括文件主的存取权限、核准用户的存取权限以及一般用户的存取权限。

- **使用信息**：，如文件建立时间、上次修改时间等。

一个文件目录也被视为一一个文件，称为目录文件。

FCB在磁盘中必须连续存放

## 文件按的逻辑结构

### 无结构文件（流式文件）

无结构文件将数据按顺序组织成记录并积累、保存，以字节(Byte) 为单位。对记录的访问只能通过穷举搜索的方式，但是管理简单，用户可以方便地对其进行操作。较适于采用字符流的无结构方式，如源程序文件、目标代码文件等。

### 有结构文件（记录式文件）

**顺序文件**

文件中的记录顺序排列，记录通常是定长的，可以顺序存储或以链表形式存储。顺序文件两种结构：第一种是**串结构**，记录之间的顺序与关键字无关，通常是按存入时间的先后进行排列，检索必须从头开始顺序依次查找。第二种是**顺序结构**，指文件中的所有记录按关键字顺序排列，可采用折半查找法，检索效率高。每次要读或写一大批记录时，顺序文件的效率是所有逻辑文件中最高的。对于顺序存储设备(如磁带)，也只有顺序文件才能被存储并能有效地工作。在经常需要查找、修改、增加或删除单个记录的场合，顺序文件的性能也比较差。

**索引文件**

建立一张索引表，为主文件的每个记录在索引表中分别设置一个表项，包含指向变长记录的指针(即逻辑起始地址)和记录长度，索引表按关键字排序，其本身也是一个定长记录的顺序文件。

**索引顺序文件**

将顺序文件中的所有记录分为若干组，为顺序文件建立一张索引表， 在索引表中为每组中的第一条记录建立一个索引项，其中含有该记录的关键字值和指向该记录的指针。

## 文件的物理结构

### 连续分配

要求每个文件在磁盘上占有一组连续的块，连续分配支持顺序访问和直接访问。

**优点**：是实现简单、存取速度快。

**缺点**：

1. 文件长度不宜动态增加

2. 删除和插入记录时，需要对相邻的记录做物理上的移动，还会:动态改变文件的长度

3. 反复增删文件后会产生外部碎片

4. 只适用于长度固定的文件

### 链接分配

采用离散分配的方式。它消除了磁盘的外部碎片，可以动态地为文件分配盘块。链接分为显示链接和隐式链接

1. **隐式链接**：目录项中含有文件第一块的指针和最后一块的指针。除最后一个盘块外，每个盘块都含有指向文件下一个盘块的指针，这些指针对用户是透明的。
   **缺点**：只适合顺序访问，随机访问效率很低，软件或硬件错误导致链表中的指针丢失或损坏，**解决方案**：将几个盘块组成簇，，按簇而不按块来分配，代价是增加了内部碎片

2. **显示链接**：链接文件个物理块的指针，显示地存放在内存的一张链接表中，整个磁盘中只有一张，称为文件分配表（FAT）这个表在系统启动时就会被读入内存，因此查找记录的过程是在内存中进行的

### 索引分配

将每个文件所有的盘块号都集中放在一起构成索引块(表)。**优点**：是支持直接访问，且没有外部碎片问题。缺点是由于索引块的分配，增加了系统存储空间的开销。索引块的大小是一个重要的问题，每个文件必须有一个索引块，因此索引块应尽可能小，但索引块太小就无法支持大文件。

**解决方案**：

1. 链接方案：将多个索引块链接起来。

2. 多层索引：通过第一级索引块指向一组第二级的索引块，第二级索引块再指向文件块。

3. 混合索引：将多种索引分配方式相结合的分配方式。

### 混合索引

直接地址；一次间接地址；多次间接地址

## 目录

一个FCB就是一个文件目录项，目录管理通过属性结构来解决和实现

### 目录结构

**单级目录结构**：

在整个文件系统中只建立一张目录表，访问文件先找FCB

实现了“按名存取”，但查找速度慢，不允许重名，不便共享

**两级目录文件;**

将文件目录分成主文件目录，和用户文件目录

主文件目录项记录用户名及相应用户文件目录所在的存储位置。用户文件目录项记录该用户文件的FCB信息。

提高了检索速度，解决了多用户之间的文件重名问题，文件系统可以在目录上实现访问限制。但是两级目录结构缺乏灵活性

**树形目录结构**：

从根目录出发的路径称为绝对路径。

“./s”就是一个相对路径，其中符号“ . ”表示当前工作目录。

树形目录结构可以很方便地对文件进行分类，层次结构清晰，也能够更有效地进行文件的管理和保护。不便实现用户共享

在树形目录中查找一个文件，需要按路径名逐级访问中间结点，增加了磁盘访问次数，这无疑会影响查询速度

**无环图目录结构**：

树形目录结构的基础上增加了一些指向同一结点的有向边，使整个目录成为一个有向无环图，

为每个共享结点设置一个共享计数器，每当图中增加对该结点的共享链时，计数器加1；每当某用户是出删除该结点时，计数器减1。仅当共享计数器为0时，才真正删除该结点，否则仅删除请求用户的共享链。

实现了文件的共享，但使得系统的管理变得更加复杂。

## 文件系统

### 文件共享

**硬链接**：

必须将共享文件或子目录链接到两个或多个用户的目录中

文件的物理地址及其他的文件属性等信息，不再放在目录项中，而放在索引结点中。在文件目录中只设置文件名及指向相应索引结点的指针。

**软链接**：

通过一个LINK文件进行共享，LINK文件中包含了目标文件的路径等。

### 文件系统在磁盘中的结构：

磁盘划分为一个或多个分区，每个分区中有一一个独立的文件系统。

1. **主引导记录**：位于磁盘的0号扇区，用来引导计算机，MBR后面是分区表，该表给出每个分区的起始和结束地址。

2. **引导块**：MBR执行引导块中的程序后，该程序负责启动该分区中的操作系统。为统一起见，每个分区都从一个引导块开始，即使它不含有一个可启动的操作系统

3. **超级块**：包含文件系统的所有关键信息

4. 文件系统中空闲块的信息，可以使用位示图或指针链接的形式给出。

### 文件系统在内存中的结构

内存中的信息用于管理文件系统并通过缓存来提高性能。这些数据在安装文件系统时被加载，在文件系统操作期间被更新，在卸载时被丢弃。

**安装表**：包含每个已安装文件系统分区的有关信息

**整个系统的打开文件表**：包含每个打开文件的FCB副本及其他信息

**每个进程的打开文件表**：包含一个指向整个系统的打开文件表中的适当条目的指针

为了创建新的文件，文件系统将为文件分配一个新的FCB

一旦文件被创建，它就能用于I/O。一旦文件被打开，内核就不再使用文件名来访问文件，而使用文件描述符

### 外存空闲空间管理

在一个卷中，存放文件数据的空间(文件区)和FCB的空间(目录区)是分离的。卷在提供文件服务前，必须做好初始化，划分好目录区和文件区

文件存储设备分成许多大小相同的物理块，并以块为单位交换信息

#### 空闲表法

属于连续分配方式，为每个文件分配一块连续的存储空间

空闲盘区的分配与内存的动态分配类似，同样采用首次适应算法和最佳适应算法等。系统在对用户所释放的存储空间进行回收时，也采取类似于内存回收的方法

**空闲链表法**：

将所有空闲盘区拉成一条空闲链。

1. **空闲盘块链**：将空闲空间以**盘块**为单位拉成一条链。 **优点**是分配和回收一个盘块的过程非常简单，**缺点**效率较低。又因它是以盘块为单位的，空闲盘块链会很长。

2. **空闲盘区链**：将磁盘上的所有空闲**盘区**拉成一条链。 每个盘区除含有用于指示下一个空闲盘区的指针外，还应有能指明本盘区大小的信息。盘区分配通常采用首次适应算法。在回收盘区时，同样也要将回收区与相邻接的空闲盘区合并。缺点：分配和回收过程复杂，但是效率高，空闲盘区链较短

3. **位示图法**：磁盘上所有的盘块都有一个二进制位与之对应。当其值为“0” 时，表示对应的盘块空闲;为“1”时，表示已分配。



