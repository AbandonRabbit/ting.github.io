[{"content":"事务四大特性 事务具有四大特性，被称为ACID：\n原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败 一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态 隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行 持久性（Durability）：事务一旦提交或滚回，它对数据库的改变就是永久的 并发事务问题 并发事务常常出现三种问题：\n问题 描述 脏读 一个事务读到另外一个事务还没有提交的数据 不可重复读 一个事务先后读取同一条记录，但两次读取的数据不同，称为不可重复读 幻读 一个事务按照条件查询数据时，没有对应的数据行，但在插入数据时，又发现该数据已经存在 事务隔离级别 事务隔离级别分为四种：\n隔离级别 脏读 不可重复读 幻读 Read uncommitted √ √ √ Read committed × √ √ Repeatable Read(默认) × × √ Serializable × × × 用户数据管理 管理用户 1/*查询用户*/ 2SELECT * FROM user 3 4/*创建用户*/ 5CREATE USER \u0026#39;用户名\u0026#39;@ \u0026#39;主机名\u0026#39; IDENTIFUED BY \u0026#39;密码\u0026#39; 6 7/*修改用户密码*/ 8ALTER USER \u0026#39;用户名\u0026#39;@ \u0026#39;主机名\u0026#39; IDENTIFUED WITH mysql_native_password BY \u0026#39;新密码\u0026#39; 9 10/*删除用户*/ 11DROPUSER \u0026#39;用户名\u0026#39;@ \u0026#39;主机名\u0026#39; 主机名可以用%通配符，表示任意\n权限控制 1/*查询权限*/ 2SHOW GRANTS FOR \u0026#39;用户名\u0026#39;@ \u0026#39;主机名\u0026#39; 3 4/*授予权限*/ 5GRANT 权限列表 ON 数据库名.表名 TO \u0026#39;用户名\u0026#39;@ \u0026#39;主机名\u0026#39; 6 7/*撤销权限*/ 8REVOKE 权限列表 ON 数据库名.表名 FROM \u0026#39;用户名\u0026#39;@ \u0026#39;主机名\u0026#39; 多个权限之间，可以使用逗号分隔\n授权时，数据库名和表名可以使用 * 进行统配，表示所有\n函数 字符串函数 函数 功能 CONCAT(S1,S2,\u0026hellip;Sn) 字符串拼接，将S1，S2，\u0026hellip; Sn拼接成一个字符串 LOWER(str) 将字符串str全部转为小写 UPPER(str) 将字符串str全部转为大写 LPAD(str,n,pad) 左填充，用字符串pad对str的左边进行填充，达到n个字符 串长度 RPAD(str,n,pad) 右填充，用字符串pad对str的右边进行填充，达到n个字符 串长度 TRIM(str) 去掉字符串头部和尾部的空格 SUBSTRING(str,start,len) 返回从字符串str从start位置起的len个长度的字符串 数值函数 函数 功能 CEIL(x) 向上取整 FLOOR(x) 向下取整 MOD(x,y) 返回x/y的模 RAND() 返回0~1内的随机数 ROUND(x,y) 求参数x的四舍五入的值，保留y位小数 日期函数 函数 功能 CURDATE() 返回当前日期 CURTIME() 返回当前时间 NOW() 返回当前日期和时间 YEAR(date) 获取指定date的年份 MONTH(date) 获取指定date的月份 DAY(date) 获取指定date的日期 DATE_ADD(date, INTERVAL expr type) 返回一个日期/时间值加上一个时间间隔expr后的 时间 DATEDIFF(date1,date2) 返回起始时间date1 和 结束时间date2之间的天数 流程控制函数 函数 功能 IF(value,t,f) 如果value为true，返回 t ，否则返回 f IFNULL(v1,v2) 如果 v1 不为空，返回 v1，否则返回 v2 CASE WHEN [ val1 ] THEN [res1] \u0026hellip; ELSE [ default ] END 如果val1为true，返回res1，\u0026hellip; 否 则返回default默认值 CASE [ expr ] WHEN [ val1 ] THEN [res1] \u0026hellip; ELSE [ default ] END 如果expr的值等于val1，返回 res1，\u0026hellip; 否则返回default默认值 存储引擎 存储结构 表空间、段、区（大小固定 1 M）、页（大小固定 16 k）、行\nMySQL的体系结构 第一层——连接层：接受客户端的链接，完成链接处理，认证授权，安全方案，检查最大链接数 第二层——服务层：SQL结构，解析器，查询优化器，缓存 第三层——存储引擎层：数据存储和提取的方式，索引在这一层实现 第四层——存储层：数据库的相关数据 存储引擎简介 存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式 。存储引擎是基于表的，而不是 基于库的，所以存储引擎也可被称为表类型。\n1/*查询建表语句*/ 2show create table 表名; 3 4/*建表时指定存储引擎*/ 5CREATE TABLE 表名( 6 字段1 字段1类型 [ COMMENT 字段1注释 ] , 7) ENGINE = 引擎名 [ COMMENT 表注释 ] ; 8 9/*查询当前数据库支持的存储引擎*/ 10show engines; InnoDB 存储引擎 在 MySQL 5.5 之后，InnoDB是默认的 MySQL 存储引擎。\n特点 DML操作遵循ACID模型，支持事务； 行级锁，提高并发访问性能； 支持外键FOREIGN KEY约束，保证数据的完整性和正确性； 文件 xxx.ibd：xxx代表的是表名，innoDB引擎的每张表都会对应这样一个表空间文件，存储该表的表结 构（frm-早期的 、sdi-新版的）、数据和索引。\n逻辑存储结构 表空间 : InnoDB存储引擎逻辑结构的最高层，ibd文件其实就是表空间文件，在表空间中可以 包含多个Segment段。 段 : 表空间是由各个段组成的， 常见的段有数据段、索引段、回滚段等。InnoDB中对于段的管 理，都是引擎自身完成，不需要人为对其控制，一个段中包含多个区。 区 : 区是表空间的单元结构，每个区的大小为1M。 默认情况下， InnoDB存储引擎页大小为 16K， 即一个区中一共有64个连续的页。 页 : 页是组成区的最小单元，页也是InnoDB 存储引擎磁盘管理的最小单元，每个页的大小默 认为 16KB。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请 4-5 个区。 行 : InnoDB 存储引擎是面向行的，也就是说数据是按行进行存放的，在每一行中除了定义表时 所指定的字段以外，还包含两个隐藏字段 MyISAM 存储引擎 是MySQL早期的默认存储引擎\n特点 不支持事务，不支持外键 支持表锁，不支持行锁 访问速度快 文件 xxx.sdi：存储表结构信息 xxx.MYD: 存储数据 xxx.MYI: 存储索引 Memory 存储引擎 Memory引擎的表数据时存储在内存中的，由于受到硬件问题、或断电问题的影响，只能将这些表作为 临时表或缓存使用。\n特点 内存存放 hash索引（默认） 文件 xxx.sdi：存储表结构信息 区别及特点 存储引擎选择 索引 分类 分类 含义 特点 关键字 主键索引 针对于表中主键创建的索引 默认自动创建, 只能 有一个 PRIMARY 唯一索引 避免同一个表中某数据列中的值重复 可以有多个 UNIQUE 常规索引 快速定位特定数据 可以有多个 全文索引 全文索引查找的是文本中的关键词，而不是比 较索引中的值 可以有多个 FULLTEXT InnoDB中的索引形式\n分类 含义 特点 聚集索引 将数据存储与索引放到了一块，索引结构的叶子 节点保存了行数据 必须有,而且只 有一个 二级索引 将数据与索引分开存储，索引结构的叶子节点关 联的是对应的主键 可以存在多个 聚集索引选取规则\n主键 使用第一个 UNIQUE 作为聚集索引 自动生成一个rowid作为隐藏的聚集索引 **回表查询：**先走二级索引找到主键值，在去聚集索引中拿到这一行的行数据\nsql性能分析 sql执行频率 1/*服务器状态信息*/ 2-- session 是查看当前会话 ; 3-- global 是查询全局数据 ; 4show [session|global] status 5 6/*查看当前数据库的INSERT、UPDATE、DELETE、SELECT的访问频次*/ 7SHOW GLOBAL STATUS LIKE \u0026#39;Com_______\u0026#39;; 慢查询日志 慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有 SQL语句的日志\n1/*慢查询日志默认没有开启，需要在配置文件（/etc/my.cnf）中配置*/ 2使用vim添加配置信息 3# 开启MySQL慢日志查询开关 4slow_query_log=1 5# 设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志 6long_query_time=2 profile详情 先使用 SELECT @@have_profiling; 查看是否支持 profile 功能\n开启 profiling ：SET profiling = 1; （可以指定在 session/global级别开启）\n1-- 查看每一条SQL的耗时基本情况 2show profiles; 3 4-- 查看指定query_id的SQL语句各个阶段的耗时情况 5show profile for query query_id; 6 7-- 查看指定query_id的SQL语句CPU的使用情况 8show profile cpu for query query_id; explain执行计划 EXPLAIN 或者 DESC命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行 过程中表如何连接和连接的顺序\n1-- 直接在select语句之前加上关键字 explain / desc 2EXPLAIN SELECT 字段列表 FROM 表名 WHERE 条件; Explain 执行计划中各个字段的含义:\nid select查询的序列号，表示查询中执行select子句或者是操作表的顺序 (id相同，执行顺序从上到下；id不同，值越大，越先执行)。 select_type 表示 SELECT 的类型，常见的取值有 SIMPLE（简单表，即不使用表连接 或者子查询）、PRIMARY（主查询，即外层的查询）、 UNION（UNION 中的第二个或者后面的查询语句）、 SUBQUERY（SELECT/WHERE之后包含了子查询）等 type 表示连接类型，性能由好到差的连接类型为NULL、system、const、 eq_ref、ref、range、 index、all 。 possible_key 显示可能应用在这张表上的索引，一个或多个。 key 实际使用的索引，如果为NULL，则没有使用索引。 key_len 表示索引中使用的字节数， 该值为索引字段最大可能长度，并非实际使用长 度，在不损失精确性的前提下， 长度越短越好 。 rows MySQL认为必须要执行查询的行数，在innodb引擎的表中，是一个估计值， 可能并不总是准确的。 filtered 表示返回结果的行数占需读取行数的百分比， filtered 的值越大越好。 索引使用 最左前缀法则 如果索引了多列（联合索引），要遵守最左前缀法则。最左前缀法则指的最左前缀法则指的是，查询时，最左变的列，必须存在，否则索引全部失效。 而且中间不能跳过某一列，否则该列后面的字段索引将失效。（与顺序无关）\n索引失效情况 范围查询中(\u0026gt;,\u0026lt;)，范围查询右侧的列索引失效。在业务允许的情况下，尽可能的使用类似于 \u0026gt;= 或 \u0026lt;= 这类的范围查询，而避免使用 \u0026gt; 或 \u0026lt;。\n在索引列上进行运算操作， 索引将失效。\n字符类型数据，不加字符串会导致索引失效\n在模糊匹配中，尾部模糊匹配，索引不会失效。头部模糊匹配，索引失效。\n当or连接的条件，其中一侧没有索引，索引失效，左右两侧字段都有索引时，索引才会生效。\n数据分布，如果MySQL评估使用索引比全表更慢，则不使用索引。\nSQL提示 use index ： 建议MySQL使用哪一个索引完成此次查询（仅仅是建议，mysql内部还会再次进 行评估） ignore index ： 忽略指定的索引。 force index ： 强制使用索引。 1select * from 表名 sql提示(索引名) where 条件; 覆盖索引 尽量使用覆盖索引（覆盖索引是指 查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到）\n前缀索引 当字段类型为字符串，有时候需要索引很长的字符串，者会让索引变得很大，此时可以将字符串的一部分前缀建立索引，可以节约空间\n1create index idx_xxxx on table_name(column(n)) ; 前缀长度\n以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值， 索引选择性越高则查询效率越高， 唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。前缀索引主要时解决长字符串数据查询产生了大量的磁盘 IO 情况\n1-- 不设置索引时的索引选择性 2select count(distinct email) / count(*) from tb_user ; 3-- 前5个字符的索引选择性 4select count(distinct substring(email,1,5)) / count(*) from tb_user ; 索引设计原则 在数据量大，且查询比较频繁的表建立索引 针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引。 选择区分度高的列，建立唯一索引，区分度越高，索引的效率越高。 字符串较长的列建立前缀索引 尽量采用联合索引，避免回表，提高查询效率 控制索引的数据量，索引越多，维护索引结构的代价就越大 在创建表的时候尽量使用 NOT NULL 约束，方便优化器更好判断索引查询效率 SQL优化 insert优化 尽量使用批量插入 手动提交事务 采用数据插入 大批量插入数据 主键顺序插入效率大于乱序插入\n使用 load 指令插入\n1-- 客户端连接服务端时，加上参数 -–local-infile 2mysql –-local-infile -u root -p 3 4-- 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关 5set global local_infile = 1; 6 7-- 执行load指令将准备好的数据，加载到表结构中 8load data local infile \u0026#39;/root/sql1.log\u0026#39; into table tb_user fields terminated by \u0026#39;,\u0026#39; lines terminated by \u0026#39;\\n\u0026#39; ; 主键优化 主键乱序插入会产生页分裂现象\n删除一行记录时，该记录只是被标记为删除，并没有进行物理删除，并且它的空间变得允许被其他记录声明使用\n主键设计原则 尽量降低主键的长度 插入数据的时，尽量选择顺序插入，选择使用AUTO_INCREMENT自增主键 尽量不使用UUID作为主键或其他主键，比如身份证号 order by优化 MySQL的排序，有两种方式： Using filesort : 通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区sort buffer中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序。 Using index : 通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要 额外排序，操作效率高。 对于以上的两种排序方式，Using index的性能高，而Using filesort的性能低，我们在优化排序 操作时，尽量要优化为 Using index。 优化注意事项 根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则 尽量使用覆盖索引 多字段排序，一个升序一个降序，注意联合索引在创建时的规则 如果不可避免的出现filesort，大数据量排序时，可以适当增大排序缓冲区大小 sort_buffer_size(默认256k)。 group by优化 Using temporary 使用到临时表\n在分组操作时，也是需要满足最左前缀法则\nlimit优化 通过覆盖索引加子查询的方式进行优化\ncount优化 无优化方案，自己做一个计数器，计算数据插入删除\n在计数的时候不计数 null 值\n尽量使用 count(*) 对这个进行了优化\nupdate数据优化 InnoDB的行锁是针对索引加的锁，不是针对记录加的锁 ,并且该索引不能失效，否则会从行锁 升级为表锁 。\n视图 视图（View）是一种虚拟存在的表。视图中的数据并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。\n1-- 创建 2CREATE [OR REPLACE] VIEW 视图名称[(列名列表)] AS SELECT语句 [WITH [CASCADED | LOCAL ] CHECK OPTION ] 3 4-- 查询 5查看创建视图语句：SHOW CREATE VIEW 视图名称; 6查看视图数据：SELECT * FROM 视图名称 ...... ; 7 8-- 修改 9方式一：CREATE [OR REPLACE] VIEW 视图名称[(列名列表)] AS SELECT语句 [ WITH 10[ CASCADED | LOCAL ] CHECK OPTION ] 11方式二：ALTER VIEW 视图名称[(列名列表)] AS SELECT语句 [ WITH [ CASCADED | 12LOCAL ] CHECK OPTION ] 13 14-- 删除 151 DROP VIEW [IF EXISTS] 视图名称 [,视图名称] .. 视图检查选项 WITH [ CASCADED | LOCAL ] CHECK OPTION：在创建视图的时候添加，在对视图进行数据操作时，对该条件进行检查\nCASCADED ：级联，检查所有父视图的检查选项，当父视图只有条件没有指定with check ，也会强制检查 LOCAL ：本地，只检查当前视图的检查选项，当相关视图只有条件没有指定with check ，也会强制检查 视图更新及作用 更新注意\n在更新时，视图中的数据必须与基表数据保持一对一关系\n存储过程 基本语法 创建 1CREATE PROCEDURE 存储过程名称 ([ 参数列表 ]) 2BEGIN 3-- SQL语句 4END ; 调用 1CALL 名称 ([ 参数 ]); 查看 1SELECT * FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_SCHEMA = \u0026#39;xxx\u0026#39;; -- 查询指 2定数据库的存储过程及状态信息 3SHOW CREATE PROCEDURE 存储过程名称 ; -- 查询某个存储过程的定义 删除 1DROP PROCEDURE [ IF EXISTS ] 存储过程名称 ; 变量 变量分为三种类型: 系统变量、用户定义变量、局部变量。\n系统变量 MySQL服务器提供，不是用户定义的，属于服务器层面。分为全局变量（GLOBAL）、会话变量（SESSION）\n基本使用语法 1/*查看系统变量*/ 2SHOW [ SESSION | GLOBAL ] VARIABLES ; -- 查看所有系统变量 3SHOW [ SESSION | GLOBAL ] VARIABLES LIKE \u0026#39;......\u0026#39;; -- 可以通过LIKE模糊匹配方式查找变量 4SELECT @@[SESSION | GLOBAL] 系统变量名; -- 查看指定变量的值 5 6/*设置系统变量*/ 7-- 默认是SESSION，会话变量。 8SET [ SESSION | GLOBAL ] 系统变量名 = 值 ; 9SET @@[SESSION | GLOBAL]系统变量名 = 值 ; 用户定义变量 基本使用语法 1-- 赋值 2SET @var_name = expr [, @var_name = expr] ... ; 3SET @var_name := expr [, @var_name := expr] ... ; 4SELECT @var_name := expr [, @var_name := expr] ... ; 5SELECT 字段名 INTO @var_name FROM 表名; 6 7-- 使用 8SELECT @var_name ; 用户定义的变量无需对其进行声明或初始化，只不过获取到的值为NULL。\n局部变量 在局部生效的变量，访问之前，需要DECLARE声明。可用作存储过程内的 局部变量和输入参数，局部变量的范围是在其内声明的BEGIN \u0026hellip; END块。\n基本使用语法 1-- 声明 2DECLARE 变量名 变量类型 [DEFAULT ... ] ; 3 4-- 赋值 5SET 变量名 = 值 ; 6SET 变量名 := 值 ; 7SELECT 字段名 INTO 变量名 FROM 表名 ... ; if 判断 1IF 条件1 THEN 2..... 3ELSEIF 条件2 THEN -- 可选 4..... 5ELSE -- 可选 6..... 7END IF; 8-- ELSE IF 结构可以有多个，也可以没有。 ELSE结构可以有，也可以没有。 参数 主要分为以下三种：IN、OUT、INOUT。\nIN 该类参数作为输入，也就是需要调用时传入值 默认 OUT 该类参数作为输出，也就是该参数可以作为返回值 INOUT 既可以作为输入参数，也可以作为输出参数 case 1-- 方式一 2CASE case_value 3WHEN when_value1 THEN statement_list1 4[ WHEN when_value2 THEN statement_list2] ... 5[ ELSE statement_list ] 6END CASE; 7 8-- 方式二 9CASE 10WHEN search_condition1 THEN statement_list1 11[WHEN search_condition2 THEN statement_list2] ... 12[ELSE statement_list] 13END CASE while 1WHILE 条件 DO 2\tSQL逻辑... 3END WHILE; repeat 1REPEAT 2 SQL逻辑... 3 UNTIL 条件 4END REPEAT; loop LOOP 实现简单的循环，如果不在SQL逻辑中增加退出循环的条件，可以用其来实现简单的死循环。 LOOP可以配合一下两个语句使用：\nLEAVE ：配合循环使用，退出循环。 ITERATE：必须用在循环中，作用是跳过当前循环剩下的语句，直接进入下一次循环。 1[begin_label:] LOOP 2\tSQL逻辑... 3END LOOP [end_label]; 4 5LEAVE label; -- 退出指定标记的循环体 6ITERATE label; -- 直接进入下一次循环 游标 游标（CURSOR）是用来存储查询结果集的数据类型\n先声明普通变量，在声明游标\n1-- 声明 2DECLARE 游标名称 CURSOR FOR 查询语句 ; 3 4-- 打开 5OPEN 游标名称 ; 6 7-- 获取 8FETCH 游标名称 INTO 变量 [, 变量 ] ; 9 10-- 关闭 11CLOSE 游标名称 ; 条件处理程序 条件处理程序（Handler）可以用来定义在流程控制结构执行过程中遇到问题时相应的处理步骤。\n1DECLARE handler_action HANDLER FOR condition_value [, condition_value]... statement ; 2 3-- handler_action 的取值： 4CONTINUE: 继续执行当前程序 5EXIT: 终止执行当前程序 6 7-- condition_value 的取值： 8SQLSTATE sqlstate_value: 状态码，如 02000 9SQLWARNING: 所有以01开头的SQLSTATE代码的简写 10NOT FOUND: 所有以02开头的SQLSTATE代码的简写 11SQLEXCEPTION: 所有没有被SQLWARNING 或 NOT FOUND捕获的SQLSTATE代码的简写 存储函数 存储函数是有返回值的存储过程，存储函数的参数只能是IN类型的。\n1CREATE FUNCTION 存储函数名称 ([ 参数列表 ]) 2RETURNS type [characteristic ...] 3BEGIN 4-- SQL语句 5RETURN ...; 6END ; characteristic说明：\nDETERMINISTIC：相同的输入参数总是产生相同的结果 NO SQL ：不包含 SQL 语句 READS SQL DATA：包含读取数据的语句，但不包含写入数据的语句。 触发器 mysql只支持行级触发，不支持语句级触发。\n触发器的这种特性可以协助应用在数据库端确保数据的完整性 , 日志记录 , 数据校验等操作\n基本语法 1-- 创建 2CREATE TRIGGER trigger_name 3BEFORE/AFTER INSERT/UPDATE/DELETE 4ON tbl_name FOR EACH ROW -- 行级触发器 5BEGIN 6\ttrigger_stmt ; 7END; 8 9-- 查看 10SHOW TRIGGERS ; 11 12-- 删除 13DROP TRIGGER [schema_name.]trigger_name ; -- 如果没有指定 schema_name，默认为当前数据库 。 锁 全局锁 对整个数据库实例加锁，加锁后整个实例就处于只读状态\n主要用于对数据库进行备份\n1-- 加锁 2flush tables with read lock ; 3 4-- 解锁 5unlock tables ; 6 7-- 数据备份 8$ mysqldump -uroot –p1234 itcast \u0026gt; itcast.sql 表级锁 表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。\n表级锁，有三种分类：表锁、元数据锁、意向锁\n表锁 1-- 加锁： 2lock tables 表名... read/write。 3 4-- 释放锁： 5unlock tables 读锁：别的客户端不能写入，但可以读\n写锁：别的客户端不能写，也不能读\n元数据锁 加锁过程系统自动控制，在访问一张表的时候会自动加上。\nMDL锁主要作用：\n维护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作 为了避免DML与DDL冲突，保证读写的正确性。 某一张表涉及到未提交的事务时，是不能够修改这张表的表结构的。 MySQL5.5中引入了MDL，当对一张表进行增删改查的时候，加MDL读锁(共享)；当对表结构进行变 更操作的时候，加MDL写锁(排他)。\n查看锁\n1# 查看所有锁 2select object_type,object_schema,object_name,lock_type,lock_duration fromperformance_schema.metadata_locks ; 意向锁 为了避免DML在执行时，加的行锁与表锁的冲突，在InnoDB中引入了意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查。\n分类：\n意向共享锁(IS): 由语句select \u0026hellip; lock in share mode添加 。 与 表锁共享锁 (read)兼容，与表锁排他锁(write)互斥。 意向排他锁(IX): 由insert、update、delete、select\u0026hellip;for update添加 。与表锁共 享锁(read)及排他锁(write)都互斥，意向锁之间不会互斥。 行级锁 锁对应的行数据，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在 InnoDB存储引擎中。\n对于行级锁，主要分为以下三类： 行锁： 锁定单个行记录的锁，防止其他事务对此行进行update和delete。 在RC、RR隔离级别下都支持。 间隙锁（Gap Lock）： 锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。 在RR隔离级别下都支持。 临键锁（Next-Key Lock）： 行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。 在RR隔离级别下支持。 行锁 InnoDB实现了以下两种类型的行锁 ：\n共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。 排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁。 注意：\n仅当共享锁和共享锁共存时兼容 其他情况兼不兼容 下面我们给出不同SQL语句相对应的行锁级别：\nSQL 行锁类型 说明 INSERT 排他锁 自动加锁 UPDATE 排他锁 自动加锁 DELETE 排他锁 自动加锁 SELECT 不加锁 SELECT \u0026hellip; LOCK IN SHARE MOOE 共享锁 需要手动在SELECT之后加LOCK IN SHARE MODE SELECT \u0026hellip; FOR UPDATE 排他锁 需要手动在SELECT之后加FOR UPDATE 行锁特点：\n默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key 锁进行搜索和索引扫描，以防止幻读。 针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁。 InnoDB的行锁是针对于索引加的锁，不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，此时就会升级为表锁。 间隙锁\u0026amp;临键锁 默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key 锁进行搜索和索引扫描，以防止幻读。\n一般出现上述锁有以下三种情况：\n索引上的等值查询(唯一索引)，给不存在的记录加锁时, 优化为间隙锁 。 索引上的等值查询(非唯一普通索引)，向右遍历时最后一个值不满足查询需求时，next-keylock 退化为间隙锁。 索引上的范围查询(唯一索引)\u0026ndash;会访问到不满足条件的第一个值为止。 注意：\n间隙锁唯一目的是防止其他事务插入间隙。间隙锁可以共存，一个事务采用的间隙锁不会阻止另一个事务在同一间隙上采用间隙锁。 ","permalink":"http://localhost:1313/posts/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","summary":"\u003ch3 id=\"事务四大特性\"\u003e事务四大特性\u003c/h3\u003e\n\u003cp\u003e事务具有四大特性，被称为ACID：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败\u003c/li\u003e\n\u003cli\u003e一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态\u003c/li\u003e\n\u003cli\u003e隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行\u003c/li\u003e\n\u003cli\u003e持久性（Durability）：事务一旦提交或滚回，它对数据库的改变就是永久的\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"并发事务问题\"\u003e并发事务问题\u003c/h3\u003e\n\u003cp\u003e并发事务常常出现三种问题：\u003c/p\u003e","title":"MySQL学习笔记"},{"content":"字符串String 设置\nSET key value\n获取 GET key\n删除 DEL key\n判断是否存在 EXISTS key\n查看有哪些键 KEYS [pattern模式匹配]\n删除所有键 FLUSHALL\n查看过期时间 TTL key\n设置过期时间 EXPIRE key time/秒\n设置一个带有过期时间的键值对 SETEX key time value\n当键不存在时设置该键值对 SETNX key value\n列表List 存储或操作一组有顺序的数据\n尾部添加 RPUSH 头部添加 LPUSH 查看 LRANGE key start stop 头删除 RPOP key [删除元素个数] 尾删除 LPOP key [删除元素个数] 指定范围删除 LTRIM key start stop 集合Set 无序集合，不允许重复元素\n添加 SADD key member 判断一个元素是否在集合中 SISMEMBER key member 删除 SREM key member 查看集合元素 SMEMBERS key 有序集合SortedSet 每个元素关联一个浮点类型的分数，按照分数对集合中的元素进行从小到大排序，成员是唯一的，分数是可以重复的\n添加 ZADD key score1 value1 [score2 value2 ……]\n查看\nZRANGE key start end [WITHSCORES]\rWITHSCORES：同时输出分数\r//查看分数\rZSCORE key value\r//查看排名\rZRANK key value 哈希Hash 字符类型的字段和值的映射表，简单来说就是一个键值对的集合，特别适合存储对象\n添加 HEST key field1 value1 [fild2 value2 ……]\n获取 HGET key field\n获取所有键值对 HGETALL key\n删除键值对 HEXISTS key field\n获取所有键 HKEYS key\n获取键的数量\nHLEN key\n发布订阅模式 无法持久化，无法记录历史\n发送：PUBLISH\n接受：SUBSCRIBE 频道名称\n消息队列Stream 轻量级消息队列，解决发布订阅功能的一些局限性，大部分命令用 X 开头\n添加消息 XADD key * field value\n* 表示随机id\nid 格式：整数-整数，第一个整数表示时间戳，第二个整数表示一个序列号，在使用时，需要保证 id 是递增的\n消息数量 XLEN key\n消息详细内容 XRANGE key start end 可以用 - + 表示显示所有内容\n删除 XDEL key ID\n也可以通过XTRIM key MAXLEN 删除消息\n读取消息 XREAD [COUNT 消息数量] [BLOCK 阻塞时间] STREAMS key start\nstart 可以为$符，表示从执行时间开始阻塞，接受最新的消息\n创建消费者组\nXGROUP CREATE 消息名称 组的名称 ID 通过 XINFO GROUPS 消息名称查看消费者组的信息\n添加消费者XGROUP CREATECONSUMER 消息名字 组名字 消费者名字\n读取消息：XREADGROUP GROUP 组名称 消费者名称 COUNT 消息数量 BLOCK 阻塞的时间 STREAMS 消息名称\n地理空间Geospatial 存储地理位置信息的数据结构，支持对地理位置进行各种计算操作，命令以GEO开头\n添加\nGEOADD 信息名字 经度 维度 城市名字 [经度 维度 城市名字 ……]\n获取经纬度\nGEOPOS 信息名字 城市名字\n计算两个地理位置之间的距离\nGEODIST 信息名字 城市名字1 城市名字2\n默认单位是米，在后面加上km为千米\n搜索指定范围内的成员并返回\nGEOSEARCH 信息名字 FROMMEMBER 城市名字1 hyperloglog 做基数统计的算法，使用随机算法来计算，通过牺牲一定的精确度换取更小的内存消耗，优点占用内存小，缺点会有一定的误差，适合做一些对精确度要求不高，而数据量非常大的统计工作\n命令以 PF 开头\n添加元素\nPFADD 元素名 元素1 [元素2 …… 元素n]\n查看基数\nPFCOUNT 元素名\n合并\nPFMERGE new元素名 元素名1 元素名2\n位图Bitmap 由二进制位组成的数组，每个位只能是0或1，可以很方便的存储只有是否两个状态信息的数据\n命令以bit开头\n创建\nSETBIT key bit1 [bit2 …… bitn]\n获取偏移量的值 GETBIT key 偏移量\n批量设置\nSET key \u0026quot;数值\u0026quot;\n位域Bitfield ？？？？？？？？？？？ 将很多小的整数存储到一个较大的位图中\n事务 不能保证所有命令执行成功，执行结果取决于事务中的命令\n主要通过 MULTI 和 EXEC / DESCARD 实现\n在发送 EXEC 命令之前 ，所有命令都会放入一个队列中缓存起来不会立即执行 在收到 EXEC 命令之后，事务开始执行，其中任何一个命令执行失败，其他命令依然会执行 在事务执行过程中，其他客户端提交的命令请求不会被插入到事务的执行命令序列中 持久化 RDB方式 在指定时间内，将内存中的数据快照写入磁盘，是某一个时间点上数据的完整副本，可以通过配置文件中的 save 参数来配置，如果宕机，在最后一次快照之后的数据全部丢失，所以这种方式只适合备份，当为redis开辟的空间比较大，那么写入磁盘的时间会很长，这期间redis处于阻塞状态，不能处理任何求情\n为此，redis提供了一种 bgsave 命令，这个命令会创建一个单独的子进程负责将数据写入磁盘，但是这中间还会有性能损耗，因为fork一个子进程也需要时间，这期间redis也是不能响应请求\nAOF方式 在执行写命令的时候，不仅会写入数据，还会将命令写入到一个追加的文件中，这个文件就是AOF文件，已日志的形式记录每一个写操作，当redis重启之后，会通过执行 AOF 文件中的命令再内存中重建整个数据库的内容\n开启方式 再配置文件中将 appendonly 这个参数的值改成 yes 就可以了\n主从复制 将一台 redis 的数据复制到其他 redis 服务器，主节点和从节点为一对多关系，数据的复制为单向的，只能主到从，一般来说主负责写操作，从负责读操作\n配置方式 默认为主节点，不需要配置\n从节点配置 把配置文件复制到根目录一份 回到根目录，复制一个-6380的文件，作为从节点的配置文件，6380就是从节点的端口号 将 port 改为6380，将pidfile、dbfilename 指向的文件后面添加-6380，pid是进程id，为了和主节点的pid文件区分开 将replicaof 地址改为127.0.0.1，将端口号改为 6379 表示现在配置的这个节点是6379这个库的从节点 链接从节点 redis-cli -p 6380\n链接成功后使用 info replication 查看链接信息\n哨兵模式 自动故障转移，哨兵会以一个独立的进程运行再Redis集群中，用来监控Redis集群中的各个节点是否运行正常，主要功能有：\n监控：通过不断地发送命令，检查Redis节点是否运行正常\n通知：如果发现某个节点出现问题，那么哨兵就会通过发布订阅模式，通知其他节点\n自动故障转移：当主节点不能正常工作的时候，哨兵会开始一个自动故障转移的操作，它会将一个从节点升级为新的主节点，然后再将其他从节点指向新的主节点\n配置步骤：\n1、添加配置文件\rvi sentinel.conf\r添加配置信息 1 表示需要一个哨兵节点同意\rsentinel monitor 主节点名称 127.0.0.1:6379 1\r2、添加哨兵节点\rredis-sentinel 配置文件名字 ","permalink":"http://localhost:1313/posts/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","summary":"\u003ch1 id=\"字符串string\"\u003e字符串String\u003c/h1\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e设置\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eSET key value\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e获取\n\u003ccode\u003eGET key\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e删除\n\u003ccode\u003eDEL key\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e判断是否存在\n\u003ccode\u003eEXISTS key\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e查看有哪些键\n\u003ccode\u003eKEYS [pattern模式匹配]\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e删除所有键\n\u003ccode\u003eFLUSHALL\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e查看过期时间\n\u003ccode\u003eTTL key\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e设置过期时间\n\u003ccode\u003eEXPIRE key time/秒\u003c/code\u003e\u003c/p\u003e","title":"Redis学习笔记"},{"content":"概念 非关系型数据库，文档型数据库\n文档类似于mysql中的行\n数据库由一个个集合组成，集合对应mysql中的表，每个集合包含多个文档，每个文档对应mysql中的一行，文档使用json的数据格式来组织和存储数据，不同的文档中间不需要有相同的结构和字段\nMongoDB 不需要事先创建好数据库和集合然后再插入数据，也不需要预先定义好集合中字段的数据类型和长度，同一个集合中的数据也不需要有相同的结构\n常用命令 显示所有数据库databases 或 show dbs\n切换当前数据库 use 数据库名称\n只有在插入集合之后, 数据库才会被真正地创建\n插入一个文档到集合中 db.集合名.insertOne({key:\u0026quot;value\u0026quot;})\n查看数据 db.集合名.find()\n插入多条数据到集合中 db.集合名.insertMany([{key:\u0026quot;value\u0026quot;},{key:\u0026quot;value\u0026quot;}])\n查询操作 limit() —— 返回n条数据\ndb.集合名.find().limit(n) sort() —— 排序\n-- 1表示按升序排序，-1表示降序\rdb.集合名.find().sort({level:1}) 按照等级和名字排序\rdb.集合名.find().sort({level: 1, name: -1}) skip() —— 跳过一些查询数据\n返回第二名开始的数据\rdb.集合名.find().sort({level:1}).limit(2).skip(1)\r一般skip函数和sort函数一起使用实现分页功能 find({field:value}) —— 条件查询\ndb.集合名.find({level:3}) --查询等级为3的用户\rdb.集合名.find({level:3},{name:1,email:1}) --只返回name和email字段\rdb.集合名.find({level:3},{email:0}) --返回除了email之外的所有字段\rdb.集合名.find({level:{$gt:3}}) --查询等级大于3的用户\r还有 lt小于，eq等于\r查询某个字段的值是否在一个数组中\rdb.集合名.find({level:{$in:[1,3]}}) --返回等级为1或者3的用户\rNot IN:表示不再这个数组中的值\r判断某个字段是否存在，不能查看某个字段的值是否存在，\rdb.集合名.find({email:{$exists:true}}) --查询有邮箱的用户\r多条件查询，默认会把多个条件组成一个and条件的查询\rdb.集合名.find({level:{$gte:3,$lte:5}}) -- 查询等级大于等于3小于等于5的用户\r也可以显示指定and，把两个条件放到一个数组里面\rdb.集合名.find({$and:[{level:{$gte:3}},{level:{$lte,5}}]}) -- 查询等级大于等于3小于等于5的用户，把and换成 or 表示或者关系\rdb.集合名.find({level:{$not:{$eq:3}}}) --查询等级不等于3的用户\rdb.集合名.find({name:{$reges:/张/}}) --查询名字中姓张的用户，张所在的位置为正则表达式 countDocuments() —— 统计文档数量\n可以传入查询条件\nfindOne() —— 查询满足条件的第一条数据\nupdateOne() —— 更新一条数据\nupdateMany() —— 更新多条数据\n如果字段不存在，会创建这个字段，并把值写入这个字段\n把等级为1 的用户的钱更新为100\rdb.集合名.updataOne({level:1},{$set:{money:100}}) deleteOne() —— 删除一条数据\ndeleteMany() —— 删除满足条件的多条数据\n删除等级为1的用户\rdb.集合名.deleteOne({level:1}) ","permalink":"http://localhost:1313/posts/mongodb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","summary":"\u003ch1 id=\"概念\"\u003e概念\u003c/h1\u003e\n\u003cp\u003e非关系型数据库，文档型数据库\u003c/p\u003e\n\u003cp\u003e文档类似于mysql中的行\u003c/p\u003e\n\u003cp\u003e数据库由一个个集合组成，集合对应mysql中的表，每个集合包含多个文档，每个文档对应mysql中的一行，文档使用json的数据格式来组织和存储数据，不同的文档中间不需要有相同的结构和字段\u003c/p\u003e","title":"MongoDB学习笔记"},{"content":"Linux 基本命令 根目录从 / 开始，后面的表示层级关系\n命令通用格式\n1command [-options] [parameter] command ：命令本身 -options ：可选，命令的一些选项，可以通过选项控制命令的行为细节 parameter ：可选，命令的参数，多用于命令的指向目标 ls命令 1ls [-a -l -h] [Linux路径] -a ： 显示所有文件，包括隐藏文件，在文件名前面会有一个 . 来表示这是一个隐藏文件 -l ： 用列表显示文件可以显示更详细的内容 -h： 不可以单独使用通常和 -l 一起使用，显示文件大小 这些命令可以组合在一起使用\ncd - pwd命令 无需选项，只有参数，表示切换到这个目录下\r直接执行，不写参数，表示回到用户的HOME目录\rcd [Linux路径] pwd 打印当前所在的目录\n相对路径和绝对路径 .表示当前目录 .. 表示上一级目录 ~ 表示HOME目录 创建目录命令 mkdir mkdir [-p] Linux路径 -p ：可选参数，表示自动创建不存在的父目录\n文件操作命令（touch、cat、more、mv、rm） //创建文件命令\rtouch Linux路径\r//查看文件内容，显示所有的\rcat Linnux路径\r//查看文件，按页显示文件，按空格键显示下一页 按q键推出\rmore Linux路径 复制文件夹命令\ncp [-r] 参数1 参数2 参数1 ：被复制文件地址 参数2 ：目的地址 -r ：用于复制文件夹使用，表示递归 移动文件命令\nmv 参数1 参数2 参数1 ：被移动文件地址 参数2 ：目的地址 当目的不存在，会创建 删除文件命令\nrm [-r -f] 参数1，参数2 ………… 参数n -r ：同cp命令一样，用于删除文件夹 -f ：强制删除 rm命令支持通配符* ，用来做模糊匹配\n* 表示匹配任何内容，包含空\n查找命令 which、find //查找一系列命令的程序文件存放在哪里\rwhich 要查找的命令 find命令——按文件名查找\nfind 起始路径 -name \u0026#34;被查找文件名\u0026#34; 被查找文件名支持通配符*\nfind命令——按文件大小查找文件\nfind 起始路径 -size +|-n[kMG]\r//示例 查找小于10kb的文件\rfind / -size -10k +、- ： 表示大于和小于 n ： 表示数字 kMG ： 表示大小单位 grep-wc-管道符 grep命令\n//从文件中通过关键字过滤文件行\rgreo [-n] 关键字 文件路径 -n ： 可选，表示在结果中显示匹配的行的行号 关键字：必填项，表示过滤的关键字，如果有空格用双引号括起来 文件路径：必填项，表示过滤内容的文件内容，可作为内容输入端口 wc命令\n//统计文件的行数、单词数量等\rwc [-c -m -l -w] 文件路径 -c ：统计bytes数量 -m：统计字符数量 -l ：统计行数 -w：统计单词数量 文件路径： 被统计的文件 **管道符\n含义：将管道符左边命令的结果作为右边命令的输入\necho-tail-重定向符 echo\necho 输出内容 反引号 `\n被 `` 包裹的内容将作为命令来执行\n重定向符 \u0026gt;和\u0026raquo;\n\u0026gt; 将左侧命令的结果，覆盖写入到符号右侧指定的文件中 \u0026gt;\u0026gt; 将左侧命令的结果，追加写入到符号右侧指定的文件中 tail命令\ntail [-f -num] Linux路径 -f ：表示持续跟踪尾部更改 -num ： 表示查看尾部多少行，默认10行 root用户 管理员用户\nsu和exit命令 //切换用户\rsu [-] [用户名]\r// - 表示切换用户后加载环境变量\r//退回上一个用户\rexit sudo命令 用来临时用root身份执行命令\nsudo 其他命令 在其他命令之前加上sudo，就可以将这条命令赋予roo授权 需要为普通用户配置sudo认证才有权利使用sudo 配置步骤：\n1、切换到root用户，执行visudo命令，会自动通过vi编辑器打开/etc/sudoers\r2、在文件的最后添加\r用户名 ALL=(ALL)\tNOPASSWD:ALL\r3、通过wq保存 4、撤销权限只需要将添加的内容删除即可 用户和用户租 Linux系统中可以：\n配置多个用户 配置多个用户组 用户可以加入多个用户组中 权限管控的两个级别\n针对用户的权限控制 针对用户组的权限控制 用户组管理 需要root用户执行\n//创建用户组\rgroupadd 用户组名\r//删除用户组\rgroupdel 用户组名 用户管理 创建用户 useradd [-g -d] 用户名 -g ： 指定用户的组，不指定-g会创建同名组，并自动加入，如果存在同名组则必须使用-g -d ： 指定用户的HOME路径，不指定，HOME路径默认在：/home/用户名 删除用户 userdel [-r] 用户名 -r ： 删除用户的HOME目录，不适用-r，该用户的HOME目录将保留 查看用户所属组 id [用户名] 用户名 ： 被查看的用户，不指定为当前用户 修改用户属组 usermod -aG 用户组 用户名 getent命令 //查看当前系统之有哪些用户\rgetent passwd\r//查看当前系统中有哪些组\rgetent group 查询用户返回7份信息：\n用户名:密码(x):用户ID:组ID:描述信息(无用):HOME目录:执行终端(默认bash)\n查询组返回3份信息\n组名称:组认证(显示为x):组ID\n权限控制 查看权限控制信息 ls -l 返回的权限信息格式：\n权限细节 硬链接数 所属用户 所属用户组\n权限细节 一共10个槽位，第1个表示这是一个文件还是文件夹，-表示文件，d表示文件夹，l表示软链接，第2-4槽位表示所属用户权限，5-7表示所属用户组权限，8-10表示所属用户组权限。\n权限代码 r ：读权限 w ： 写权限 x ： 执行权限，针对文件夹表示是否可以cd到这个工作目录下 chmod 命令 修改权限命令\n只有文件、文件夹的所属用户和root用户可以修改\nchmod [-R] 权限 文件或文件夹\r//示例，u表示所属用户，g表示所属用户组，o表示其他用户\rchmod u=rwx,g=rwx,o=rwx test.txt\r//简写 r=4,w=2,x=1,用相应权限数字加起来的数字表示拥有的权限\rchmod 751 test.txt -R ： 对文件夹中的全部内容应用同样的操作 chown命令 修改所属用户或用户组\n普通用户无法修改所属为其他用户或组，所以此命令只适用于root用户执行\nchown [-R] [用户][:][用户组] 问价或文件夹 各类小技巧快捷键 功能 快捷键 强制退出 ctrl + c 退出或登出 ctrl + d 历史命令搜索 history 历史命令匹配(向上搜索第一个匹配的命令，会直接执行) ！命令 历史命令搜索(向上搜索第一个匹配的命令，会显示完整命令) ctrl + r 光标移动 动作 快捷键 跳到命令开头 ctrl + a 跳到命令结尾 ctrl + e 向左跳一个单词 ctrl + -\u0026gt; 向右跳一个单词 ctrl + \u0026lt;- 软件安装 CentOS安装 通过yum命令。yum：RPM包软件管理器，用于自动化安装配置Linux软件，并可以自动解决依赖问题\n该命令需要root权限，并联网\nyum [-y] [install | remove | search] 软件名称 -y：自动确认，无需手动确认安装或卸载的过程 install：安装 remove：卸载 search：搜索 Ubuntu安装 使用的是apt包管理器，同样需要root权限并联网\napt [-y] [install | remove | search] 软件名称 -y：自动确认，无需手动确认安装或卸载的过程 install：安装 remove：卸载 search：搜索 systemctl命令 服务控制命令\n只有软件集成到这个systemctl中才能使用这个命令\nsystemctl start | stop | tatus | enable | disable 服务名 start ： 启动 stop：关闭 status：查看状态 enable：开启开机自启 disable：关闭开机自启 软连接 将文件或文件夹链接到其他位置，类似快捷方式\nln -s 参数1~参数2 -s ：创建软连接 参数1 ：被链接文件 参数2：要链接去的目的 日期和时区 date [-d] [+格式化字符串]\r//显示年月日，如果有空格使用双引号包裹\rday +%Y-%M-%d\r//增加一天时间\rday -d \u0026#34;-1 day\u0026#34; +%Y-%M-%d -d：按照给定格式显示日期，一般用于日期计算 支持的时间标记\nyear 年 month 月 day 天 hour 小时 minute 分钟 second 秒 日期格式化字符串\n%Y：年 %y：年的后两位数字 %M：月 %d：日 %H：小时 %M：分钟 %S：秒 %s：自1970-01-01到现在的秒数 修改Linux时区 //删除时区文件\rrm -f /etc/localtime\r//创建软连接\rsudo ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime 自动校准时间 ntp 程序 安装yum -y install ntp\n启动systemctl start ntpd\n设置开机启动 systemctl enable ntpd\n手动校准 ntpdate -u ntp服务器地址 IP地址和主机名 如果无法使用 ifconfig 命令，安装 net-toole\n主机名 查看主机名 hostname 修改主机名 //重新登陆就可以看到主机名已经更改\rhostnamectl set-hostname newnname 配置固定IP地址 1、打开文件\rvim /etc/sysconfig/network-scripts/ifcfg-ens33\r2、修改BOOTPROTO参数为static\r3、添加如下内容\rIPADDR=\u0026#34;固定ip地址\u0026#34;\rNETMASK=\u0026#34;子网掩码\u0026#34;\rGATEWAY=\u0026#34;网关地址\u0026#34;\rDNS1=\u0026#34;dns地址，可以设置成网关地址\u0026#34;\r4、重新启动网卡\rsystemctl restart network 网络请求和下载 ping命令 检查网络是否可联通状态\nping [-c num] ip或主机名 -c：检查的次数 wget命令 非交互式的文件下载器，可以在命令行内下载网络文件\nwget [-b] url -b：可选，后台下载，会将日志写入到当前工作目录的wget-log文件 curl命令 发送http网络请求，可用于：下载文件、获取信息等\ncurl [-O] url -O：用于下载文件，当url是下载链接时，可以使用这个选项保存文件 cip.cc返回当前主机 ip 地址\n端口 Linux系统可以支持 65535 个端口，这些端口分为 3 类\n公认端口：1~1023，系统内置或知名程序的预留使用，非特殊需要，不占用这个端口 注册端口：1024~49151，随意使用，用于松散的绑定一些程序、服务 动态端口：49152~65535，不固定绑定程序，而是当程序对外进行网络连接时，用于临时使用 查看端口占用 nmap 命令 查看指定ip地址的端口占用情况\n//需要先安装 nmap\rnmap 被查看的ip地址 netstat 命令 查看本机指定端口占用情况\n//需要安装 net-tools\rnetstat -anp | grep 端口号 进程管理 查看进程 ps [-e -f] -e：显示全部进程 -f：以完全格式化的形式展示出信息 可以配合管道符查看指定的进程\n从左到右显示的信息分别是\n标题 描述 UID 进程所属的用户ID PID 进程号 C CPU占用率 STIME 启动时间 TTY 启动此进程的终端序号，如显示？，表示非终端启动 TIME 占用CPU时间 CMD 进程对应的名称或启动路径或启动命令 关闭进程 kill [-9] 进程ID -9：强制关闭 主机状态 系统资源监控 top 命令 显示内容介绍 第一行： 命令名称 - 当前系统时间，启动了多长时间，登录用户数量，系统在1分钟，5分钟，15分钟的平均负载 第二行： 当前进程数，在运行的进程，睡眠的进程，停止的进程，僵尸进程 第三行： cpu使用率，us:用户cpu使用率，sy:系统cpu使用率，ni:高优先级进程占用CPU时间百分比，id:空闲cpu率，wa:IO等待cpu占用率，hi:cpu硬件中断率，si:cpu软件中断率，st:强制等待占用cpu率 第四、五行： Kib Mem:物理内存，KibSwap：虚拟内存，total总量，free空闲，used使用，buff/cachebuff和cache占用， 后面表格中的内容 字段 描述 PID 进程id USER 进程所属用户 PR 进程优先级，越小越高 NI 负值表示高优先级，正表示低优先级 VIRT 进程使用虚拟内存，单位KB RES 进程使用物理内存，单位KB SHR 进程使用共享内存，单位KB S 进程状态(S休眠，R运行，Z僵死，N负数优先级，I空闲) %CPU cpu占用率 %MEM 内存占用率 TIME+ CPU使用时间，单位10毫秒 COMMAND 进程命令或名称或程序文件路径 top命令支持的选项 -p：只显示某个进程信息 -d：设置刷新时间，默认是5s -c：显示产进程的完整命令，默认是进程名 -n：指定刷新次数 -b：以非交互全屏模式运行， -i：不显示任何闲置idle或无用zombie的进程 -u：查找特定用户启动的进程 top交互式选项 以非-b方式启动，就可以产生交互，通过按下相应的键，产生不一样的功能\n按键 功能 h 显示帮助画面 c 显示产生进程的完整命令 f 可以选择需要展示的项目 M 按照驻留内存大小排序 P 根据cpu使用百分比大小排序 T 根据时间/累计时间排序 E 切换顶部内存显示单位 e 切换内存显示单位 l 切换显示平均负载和启动时间信息 i 不显示限制或无用的进程等同于-i t 显示cpu状态信息 m 切换显示内存信息 磁盘信息监控 df命令 查看硬盘的使用情况\ndf [-h] -h：以更加人性化的单位显示 iostat命令 查看cpu、磁盘的相关信息\niostat [-x][num1][num2] -x：显示更多信息 num1：刷新间隔，num2：刷新几次 rrqm/s：每秒这个设备相关的读取请求有多少被merge\nrKB/s：每秒发送到设备的读取请求数\nwkb/s：每秒发送到设备的写入请求数\n%util：磁盘利用率\n网络监控 sar命令\nsar -n DEV num1 num2 -n：查看网络，DEV表示查看网络接口 num1：刷新间隔，num2：刷新次数 环境变量 环境变量是操作系统在运行的时候记录的一些关键性信息，用以辅助系统运行\n查看环境变量 env命令\nenv 环境变量是一种 KeyValue 型数据结构\n环境变量PATH：记录了系统执行任何命令的搜索路径，用冒号隔开，当执行命令时，会按照顺序从路径中搜索要执行的程序的本体\n**$**符号：用于取“变量”的值，通过语法 $环境变量名来获取，当和其他内容混合在一起的时候，通过{}将变量名包裹起来\n设置环境变量 临时设置：\nexport 变量名 = 变量值 永久生效：\n针对当前用户生效，配置在当前用户的 ~/.bashrc 文件中 针对所有用户生效，配置在系统的 ~/etc/.profile 文件中 通过语法source 配置文件，进行立即生效，或者重新登录 环境变量配置过程\n//配置环境变量针对当前用户生效\rvi ~/bashrc\r//添加配置信息\rexport pathName=Value\r//立即生效\rsource .bashrc 自定义环境变量PATH //在配置文件中添加\rexport PATH=$PATH:/程序目录\r//立即生效\rsource 配置文件目录 上传和下载 通过鼠标拖拽实现\nrz、sz命令\n需要有对源文件和目的地的读写权限\n压缩和解压 常见的压缩格式\nzip：Linux、win、Mac常用 7zip：win常用 rar：win常用 tar：linux、Mac常用 gzip：linux、Mac常用 tar命令 .tar：称为tarball，归档文件，简单的将文件组装到一个.tar的文件内，没有太多文件体积的减少，只是简单的封装 .gz：常见为.tar.gz、gzip格式压缩，使用gzip压缩算法将文件压缩到一个文件内，可以极大的减少压缩后的体积 tar [-c -v -x -f -z -C] 参数1 参数2 …… 参数n -c：创建压缩文件，用于压缩模式 -v：显示压缩，解压过程，用于查看进度 -x：解压模式 -f：要创建的文件，或解压的文件 -z：gzip模式，不适用-z就是普通的 tarball 格式 -C：选择解压的目的地，用于解压模式 参数使用注意事项 -z选项在使用时，一般处于选项位第一个\n-f选项在使用时，必须在选项位最后一个\n-C选项在使用时，和解压所需的其他参数分开\n常用的 tar 解压组合 //解压test.tar，将文件解压到当前目录\rtar -xvf test.tar\r//解压test.tar，将文件解压到指定目录(/home/admin)\rtar -xvf test.tar -C /home/admin\r//以Gzip模式解压test.tar.gz，将文件解压到指定目录\rtar -zxvf test.tar.gz -C /home/admin zip — unzip 命令 将文件压缩为zip格式\n压缩文件 zip zip [-r] 参数1，参数2 …… 参数n -r：被压缩文件包含文件夹时，使用该选项 参数1：创建的压缩文件名 参数2~参数n：压缩的文件 解压文件 unzip unzip [-d] 参数1 -d：指定解压之后存放位置 参数1：被解压的文件 解压时同名内容会替换\nMySQL安装 5.7版本 安装 配置yum仓库\n//更新密钥\rrpm --import https://repo.mysql.com/RPM-GPG-KEY-MYSQL-2022\r//安装Mysql yum库\rrpm -Uvh http://repo.mysql.com//mysql57-community-release-el7-7.noarch.rpm 安装MySQL\nyum install -y mysql -community-server 设置开机启动\nsystemctl start mysqld\rsystemctl enable mysqld 配置 主要配置管理员用户的密码以及允许远程登录的权限\n获取MySQL的初始密码\n# 过滤 /var/log/mysqld.log 文件中的temporary password关键字，该文件是mysql安装运行过程中的日志文件\rcat /var/log/mysqld.log | grep \u0026#34;temporary password\u0026#34; 登录MySQL数据库系统\n执行\rmysql -uroot -p\r输入前面获取到的初始密码 修改 root 用户密码\nALTER USER \u0026#39;root\u0026#39;@\u0026#39;localhost\u0026#39; IDENTIFIED BY \u0026#39;密码\u0026#39;; Redis安装和部署 配置 EPEL 仓库\nyum install -y epel-release 安装redis\nyum install -y redis 设置 redis 服务\n//开机自启动\rsystemctl enable redis\r//关闭开机自启动\rsystemctl disable redis\r//启动\rsystemctl start redis\r//关闭\rsystemctl stop redis\r//查看状态\rsystemctl status redis 放行防火墙\n//方式一，关闭防火墙\rsystemctl stop firewalld\rsystemctl disable firewalld\r//方式二，放行 redis 服务端口(6379)\rfiremall-cmd --add-port=6379 ","permalink":"http://localhost:1313/posts/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","summary":"\u003ch1 id=\"linux-基本命令\"\u003eLinux 基本命令\u003c/h1\u003e\n\u003cp\u003e根目录从  /  开始，后面的表示层级关系\u003c/p\u003e\n\u003cp\u003e命令通用格式\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e1\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ecommand\u003c/span\u003e \u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"n\"\u003eoptions\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003eparameter\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003ecommand ：命令本身\u003c/li\u003e\n\u003cli\u003e-options ：可选，命令的一些选项，可以通过选项控制命令的行为细节\u003c/li\u003e\n\u003cli\u003eparameter ：可选，命令的参数，多用于命令的指向目标\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"ls命令\"\u003els命令\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e1\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003els\u003c/span\u003e \u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"n\"\u003el\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"n\"\u003eh\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003eLinux路径\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e-a ： 显示所有文件，包括隐藏文件，在文件名前面会有一个  .  来表示这是一个隐藏文件\u003c/li\u003e\n\u003cli\u003e-l ： 用列表显示文件可以显示更详细的内容\u003c/li\u003e\n\u003cli\u003e-h： 不可以单独使用通常和 -l 一起使用，显示文件大小\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e这些命令可以组合在一起使用\u003c/p\u003e","title":"Linux学习笔记"},{"content":"基础 broker： 理论上一个一台机器就是一个 broker，也可以是一台机器上有多个 broker 进程，不过要使用不同的端口号区分\n**Topic：**一个broker内部有多个 topic ，存储某一类的业务数据\n**Partition：**同一个 Topic 分成多个 Partition ，每一个 Partition 都是一个小的队列，同一个 Topic 的 同一个 Partition 又有很多备份，分为 Leader(主) 和从 Follower(从)\n**Leader 和 Follower ：**同一个 Topic 的 同一个 Partition 下的 Leader 和 Follower 存储在不同的 Broker上，主要容灾，当一个Broker挂掉，不至于数据丢失\n把一个 Topic 分成多个 Partition 主要是为了方便消费的受负载均衡，一般情况下一个消费者或消费者组至少对应一个 Partition ，如果消费者或消费者数量大于 Partition ，则至少会有一个 消费者 处于阻塞状态 **offset：**在消费一个 Partition 里面的数据时，一边读取，一边向 kafka 集群汇报当前读到的位置，这个位置在 kafka 内部使用 offset 标记，每一个写进 kafka 中的数据都会有一个 offset\n实现过程 生产者写入数据时怎么选择 Partition？\n可以指定选择那个 Partition 如果没有指定，会根据写入这条数据的 key 决定选择那个 Partition 如果没有 key 就根据时间片轮询的方式选择 确定 Partition 之后的工作流程：\n首先询问 kafka 集群这个 Topic 的这个 Partition 的 leader 是那台服务器，是哪一个 broker 将数据发送给 leader leader 将数据写入本地磁盘 follower 从 leader 拉取消息数据 follower 将消息写入本地磁盘后向 leader 发送一个确认消息 ack leader 向 生产者 发送一个确认消息 ack 生产者可以设置是否需要对方返回 ack 消息\n0 不需要返回，安全性最低但是效 率最高。 1 只确保leader发送成功。 all 完成所有 ack 确认流程，安全性最⾼高，但是效率最低。 代码示例 消费者信息\n1func readKafka(ctx context.Context) { 2\treader = kafka.NewReader(kafka.ReaderConfig{ 3\tBrokers: []string{\u0026#34;localhost:9092\u0026#34;}, //可以配置多个 4\tTopic: topic, 5\tCommitInterval: 1 * time.Second, //设置报告策略 6\tGroupID: \u0026#34;rec_team\u0026#34;, //所属的消费者组 7\tStartOffset: kafka.FirstOffset, //设置新的消费方消费数据起始位置。只在消费方创建时有效 8\t}) 9\t//defer reader.Close() 10\tfor { 11\tif msg, err := reader.ReadMessage(ctx); err != nil { 12\tfmt.Printf(\u0026#34;读取kafka失败 %v\\n\u0026#34;, err) 13\tbreak 14\t} else { 15\tfmt.Printf( 16\t\u0026#34;topic:%s\\t partition:%d\\t offset:%d\\t key:%s value:%s\\t \\n\u0026#34;, 17\tmsg.Topic, 18\tmsg.Partition, 19\tmsg.Offset, 20\tstring(msg.Key), 21\tstring(msg.Value), 22\t) 23\t} 24\t} 25} 生产者\n1func writeKafka(ctx context.Context) { 2\twriter := \u0026amp;kafka.Writer{ 3\tAddr: kafka.TCP(\u0026#34;localhost:9092\u0026#34;), //链接地址 4\tTopic: topic, //设置消息主题 5\tBalancer: \u0026amp;kafka.Hash{}, //负载均衡算法 6\tWriteTimeout: time.Second * 1, //设置超时时间 7\tRequiredAcks: kafka.RequireNone, //设置超时确认级别 8\tAllowAutoTopicCreation: true, //是否可以自动创建 topic，一般为false，由运维创建 9\t} 10\tdefer writer.Close() 11\tfor i := 0; i \u0026lt; 3; i++ { 12\tif err := writer.WriteMessages( //批量写入，这个操作是原子操作 13\tctx, 14\tkafka.Message{Key: []byte(\u0026#34;1\u0026#34;), Value: []byte(\u0026#34;h1\u0026#34;)}, 15\tkafka.Message{Key: []byte(\u0026#34;2\u0026#34;), Value: []byte(\u0026#34;h2\u0026#34;)}, 16\tkafka.Message{Key: []byte(\u0026#34;3\u0026#34;), Value: []byte(\u0026#34;h3\u0026#34;)}, 17\tkafka.Message{Key: []byte(\u0026#34;4\u0026#34;), Value: []byte(\u0026#34;h4\u0026#34;)}, 18\tkafka.Message{Key: []byte(\u0026#34;5\u0026#34;), Value: []byte(\u0026#34;h5\u0026#34;)}, 19\t); err != nil { 20\tif err == kafka.LeaderNotAvailable { 21\ttime.Sleep(time.Millisecond * 500) 22\tcontinue 23\t} else { 24\tfmt.Printf(\u0026#34;批量插入数据失败 kafka：%v\\n\u0026#34;, err) 25\t} 26\t} else { 27\tbreak 28\t} 29\t} 30} ","permalink":"http://localhost:1313/posts/kafka%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","summary":"\u003ch1 id=\"基础\"\u003e基础\u003c/h1\u003e\n\u003cp\u003e\u003cstrong\u003ebroker：\u003c/strong\u003e 理论上一个一台机器就是一个 broker，也可以是一台机器上有多个 broker 进程，不过要使用不同的端口号区分\u003c/p\u003e\n\u003cp\u003e**Topic：**一个broker内部有多个 topic ，存储某一类的业务数据\u003c/p\u003e","title":"Kafka学习笔记"},{"content":"简介 RPC的全称是Remote Procedure Call，远程过程调用。这是一种协议，是用来屏蔽分布式计算中的各种调用细节，使得你可以像是本地调用一样直接调用一个远程的函数。\n客户端与服务端沟通的过程\n客户端发送数据(以字节流的方式)编码 服务端接受并解析。根据约定知道要执行什么。然后把结果返回给客户解码 RPC\nRPC就是将上述过程封装下，使其操作更加优化 使用一些大家都认可的协议使其规范化 做成一些框架。直接或间接产生利益 gRPC\ngRPC是一个高性能的、开源的通用的RPC框架。\n在gRPC中，我们称调用方为client，被调用方为server。\ngRPC会屏蔽底层的细节，client只需要直接调用定义好的方法，就能拿到预期的返回结果。对于server端来说，还需要实现我们定义的方法。同样的，gRPC也会帮我们屏蔽底层的细节，我们只需要实现所定义的方法的具体逻辑即可。\n此外，gRPC还是语言无关的。可以用C++作为服务端，使用Golang、 Java等作为客户端。为了实现这一点，我们在\u0026quot;定义服务“和在编码和解码的过程中，应该是做到语言无关的。\ngRPC使用了Protocol Buffss。这是谷歌开源的一套成熟的数据结构序列化机制。\n序列化:将数据结构或对象转换成二进制串的过程\n反序列化:将在序列化过程中所产生的二进制串转换成数据结构或者对象的过程\nprotobuf是谷歌开源的一种数据格式，适合高性能，对响应速度有要求的数据传输场景。因为profobuf是二进制数据格式，需要编码和解码，数据本身不具有可读性。因此只能反序列化之后得到真正可读的数据。\n优势\n序列化后体积相比Json和XML很小，适舍网络传输 支持跨平台多语言 消息格式升级和兼容性还不错 序列化反序列化速度很快 安装 安装Protocol Buffers 下载地址：https://github.com/protocolbuffers/protobuf/releases 下载之后记得配置环境变量，再命令行中输入protoc\n安装gRPc的核心库 go get google.go1ang.org/grpc\n安装代码生成工具\n1go install google.golang.org/protobuf/cmd/protoc-gen-go@latest 2 3go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest 生成RPC文件\n1//生成go语言文件 2protoc --go_out=. hello.proto 3 4//生成rpc相关文件 5protoc --go-grpc_out=. hello.proto proto文件 1//指定语法版本 2syntax=\u0026#34;proto3\u0026#34;; 3 4//指定生成目录 . 表示当前目录 service表示生成的go文件的包名为service 5option go_package =\u0026#34;.;service\u0026#34;; 6 7// 结构体 定义参数 8message HelloRequest{ 9 //message 消息格式，需要传输的数据格式的定义 10 11 //后面的数字为消息号 指定生成位置 12 string requestName = 1; 13 int64 agr = 2; 14 /* 15 字段规则： 16 required：必填字段，不设置会导致编码异常，在 protobuf2 中使用，在 protobuf3 中删除 17 optional：可选字段，protobuf3中没有 required 和 optional 等说明关键字，都默认为 optional 18 repeated：可重复字段，在go语言中会定义成切片 19 20 每个字段都必须有自己唯一的标识号 21 22 消息结构体可以嵌套，如果调用内部结构体直接调用就好 23 */ 24} 25 26// 结构体 定义参数 27message HelloResponse{ 28 string responseMsg=1; 29} 30 31//定义一个服务 包含一些方法 32service SayHello{ 33 //定义一个SayHello方法，需要传入HelloRequest参数，返回一个HelloResponse参数 34 rpc SayHello(HelloRequest) returns (HelloResponse){} 35 36} protobuf文件只是服务端和客户端调用的约束，只是一个接口文档，server端只需要把方法实现，客户端调用这个方法\n服务端编写 创建gRPC Server对象，你可以理解为它是Server端的抽象对象 将server(其包含需要被调用的服务端接口)注册到gRPC Server的内部注册中心。这样可以在接受到请求时，通过内部的服务发现，发现该服务端接口并转接进行逻辑处理 创建Listen，监听TCP端口 gRPC Server开始lis.Accept，直到Stop 客户端编写 创建与给定目标(服务端)的连接交互 创建server的客户端对象 发送RPC请求，等待同步响应，得到回调后返回响应结果 输出响应结果 加密 此处说到的认证，不是用户的身份认证，而是指多个server和多个client之间，如何识别对方是谁，并且可以安全的进行数据传输.\n加密方式：\nSSL/TLS认证方式(采用http2协议) 基于Token的认证方式(基于安全连接) 不采用任何措施的连接，这是不安全的连接(默认采用http1) 自定义的身份认证 客户端和服务端之间调用，我们可以通过加入证书的方式，实现调用的安全性\nTLS (Transport Layer Security，安全传输层)，TLS是建立在传输层TCP协议之上的协议，服务于应用层，它的前身是SSL (Secure Socket Layer,安全套接字层)，它实现了将应用层的报文进行加密后再交由TCP进行传输的功能。\nTLS协议主要解决如下三个网络安全问题。\n保密(message privacy)，保密通过加密encryption实现，所有信息都加密传输，第三方无法嗅探 完整性(message integrity)，通过MAC校验机制，一旦被篡改，通信双方会立刻发现; 认证(mutual authentication)，双方认证,双方都可以配备证书，防止身份被冒充; TSL认证方式实现 便捷包下载地址：http://slproweb.com/products/Win320penSSL.html 安装完之后配置环境变量\n使用命令行输入 openssl 测试安装是否成功\n生成证书\n1#1、生成私钥文件 key 输出为 server.key 文件 2openssl genrsa -out server.key 1024 3 4#2、生成证书文件 crt 全部回车即可，接下来的提示输入信息可以不填 5openssl req -new -x509 -key server.key -out server.crt -days 36500 6 7#3、生成csr 8openssl req -new -key server.key -out server.csr 1# 更改openss7.cnf (Linux是openssl.cfg) 2# 1) 复制一份你安装的openssl的bin目录里面的openssl.cnf 文件到你项目所在的目录 3# 2）找到[ CA_default ]，打开 copy_extensions = copy (就是把前面的#去掉) 4# 3）找到[ req ]，打开req_extensions = v3_req # The extensions to add to a certificate request 5# 4) 找到[ v3_req ]，添加subjectAltName = @alt_names 6# 5) 添加新的标签[ alt_names ]，和标签字段 7DNS.1 = * .kuangstudy . com 1#生成证书私钥test.key 2openssl genpkey -algorithm RSA -out test.key 3 4#通过私钥test.key生成证书请求文件test.csr（注意cfg和cnf) 5openssl req -new -nodes -key test.key -out test.csr -days 3650 -subj \u0026#34;/C=cn/OU=myorg/O=mycomp/CN=myname \u0026#34; -config ./openssl.cnf -extensions v3_req 6#test.csr是上面生成的证书请求文件。ca.crt/server.key是cA证书文件和key，用来对test.csr进行签名认证。这两个文件在第一部分生成。 7 8#生成SAN证书pem 9openssl x509 -req -days 365 -in test.csr -out test.pem -CA server.crt -CAkey server.key -CAcreateserial -extfile ./openssl.cnf -extensions v3_req 在代码中使用\n1//服务端使用步骤 2//创建认证 3creds,err := credentials.NewServerTLSFromFile(\u0026#34;SAN证书绝对路径\u0026#34;,\u0026#34;私钥绝对路径\u0026#34;) 4//开启认证 在创建gRPC服务时将creds带入进去 5grpcServer := grpc.NewServer(grpc.Creds(creds)) 6 7//客户端使用步骤 8creds,err := credentialsNewClientTLSFromFile(\u0026#34;SAN证书绝对路径\u0026#34;,\u0026#34;请求域\u0026#34;) 9conn, err := grpc.NewClient(\u0026#34;127.0.0.1:9090\u0026#34;, grpc.WithTransportCredentials(creds)) token认证实现 ","permalink":"http://localhost:1313/posts/grpc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","summary":"\u003ch1 id=\"简介\"\u003e简介\u003c/h1\u003e\n\u003cp\u003eRPC的全称是Remote Procedure Call，远程过程调用。这是一种协议，是用来屏蔽分布式计算中的各种调用细节，使得你可以像是本地调用一样直接调用一个远程的函数。\u003c/p\u003e","title":"GRPC学习笔记"},{"content":"序言 内存管理主要包含两个动作：分配和释放。逃逸分析就是服务于内存分配的，而内存的释放有GC负责\n逃逸分析 基本数据类型一般来说分配在栈区，编译器存在一个逃逸分析\n引用数据类型一般分配到堆区\n用来标识变量内存应该被分配到栈区还是堆区，分配时遵守一下两种规则\n指向栈上对象的指针不能被存储到堆中 —— 堆中的变量通常生命周期更长 指向栈上对象的指针不能超过该栈对象的生命周期 init 函数 每个源文件都可以有一个 init 函数，执行顺序，先执行变量定义的函数，最后执行main函数\n先执行引入文件的 init 函数在执行当前文件的 init 函数\n指针 函数传递参数时，大对象是否要传递指针，要进行分析，因为在内存分配机制中，这个大对象的内存会被分配到堆上，增加系统开销\n类型转换 1目标类型(V) 注意：\n数据类型可以大转小，也可以小转大 被转换的是变量存储的数据(值)，变量本身的数据类型并没有发生变化 如果将高精度转换为低精度，编译时不会报错，只是转换的结果是按溢出处理 数据类型转换必须显示转换 基本数据类型转 string 1//方式一 2fmt.Sprintf(format_String,interface{}) //返回string 3 4//方式二 5使用strconv包的函数 错误处理机制 错误处理方式：defer、panic、recover\n可以抛出一个 panic 的异常，然后在 defer 中通过 recover 捕获这个异常，然后正常处理\n1defer fun (){ 2 err := recover()\t//recover()内置函数，可以捕获异常 3 if err != nil{\t//说明捕获到错误 4 fmt.Println(\u0026#34;err=\u0026#34;,err) 5 //错误处理 6 } 7}() 自定义错误 1//使用 errors.New 和 panic 内置函数 2errors.New(\u0026#34;错误说明\u0026#34;) //返回一个error类型的值，表示一个错误 3panic //内置函数 goroutine 协程和主线程 go协程的特点\n有独立的栈空间 共享程序堆空间 调度由用户控制 协程是轻量级的线程 MPG模式 M：操作系统的主线程（物理线程） P：协程执行需要的上下文 G：协程 设置运行 cpu 数目 1.8之前需要设置\n1.8之后不需要设置，默认运行在多核上\n1func main(){ 2 cpuNum := runtime.NumCPU() 3 fmt.Println(\u0026#34;cpuNum\u0026#34;,cpuNum) 4 5 runtime.GOMAXPROCS(cpuNum - 1) 6 fmt.Println(\u0026#34;ok\u0026#34;) 7} 调度器的设计策略 复用线程\nwork stealing 机制：将线程a上等待的协程换到空闲的线程上面执行 hand off 机制：当线程a有多个协程，并当前运行的协程被阻塞或等待，则新建一个线程，将线程a上面的协程放到新建的线程上，然后将线程a睡眠，等到阻塞的协程运行完毕，根据情况将这个协程销毁或放在其他队列，并将所在的线程销毁 利用并行\n通过 GOMAXPROCS 限制 P 的个数，\n抢占\n每个 G 最多可以使用 CPU 10ms 如果没执行完毕，则被新的 G 抢占\n全局 G 队列\n对 work stealing 机制的补充，当所有 P 的本地队列都为空时，从全局队列拿取（当 G 被阻塞或睡眠时放入全局队列）\n管道channel 管道一定不能被读取者close()\n管道不能只有写或只有读，必须两者都有，可以频率不一致，否则会触发deadlock\n一个数据结构 - 队列 先进先出的 线程安全，多goroutine访问时，不需要加锁，不会发生资源竞争问题 有类型，一个string的channel只能放string类型数据\n1//定义/声明 2//可以声明为只读或只写，在 chan 前面或后面加上 \u0026lt;- 3var 变量名 chan 数据类型 4 5//初始化 6变量名 = make(chan 数据类型，长度) 7 8//向管道写入数据 9变量名\u0026lt;- value 10 11//取值 12value\u0026lt;- 变量名 13 14//注意 15空接口类型，在读取的时候要进行类型断言 说明：\nchannel 是引用类型 channel必须初始化才能写入数据，即make后才能使用 管道是有类型的，intChan只能写入整数 int 数据放满就不能再放，数据取完就不能再取 遍历和关闭 关闭 当channel关闭后，不能再写入数据，只能读数据\n1//使用内置函数close可以关闭channel 2close(channelName) 遍历 使用for-range遍历\n再遍历时，如果channel没有关闭，会出现deadlock的错误 再遍历时，如果channel已经关闭，则会正常遍历 1for v:=range channel{ 2 //循环体 3} go run : 编译并运行\ngo build ：编译程序，并生成一个可运行的exe文件\nbuindin 内置函数\n单元测试 正文 变量声明注意事项\n变量使用:=声明只能在函数体内使用\n多变量不同类型声明方式\n1var( 2\tk int 3 t 4) 函数的多返回值\n返回值是匿名的，返回值跟在 return 后面\n返回值有名称的，在函数最后赋值，只写 return 就好\n导包\n.：表示引入这个包的所有变量和方法，在使用的时候可以直接使用这个包里面的方法和变量，类似将这个包里面的代码插入到当前包 _：只调用这个包的 init 方法 别名：在前面直接加上别名，默认为是包名 切片细节\n对切片再进行切片，两个切片会指向同一个内存地址，\n使用copy操作切片，会创建新的切片，\nappend操作原理\n先创建一个新的数组，将旧的数组内容 copy 过去，然后将新添加的内容追加过去，再将旧的数组删除，最后将指针指向新的数组\n泛型 在1.18版本加入了对泛型的支持，泛型是为了解决执行逻辑与类型无关的问题，\n泛型方法 1func Sum[T int | float64](a, b T) T { 2 return a + b 3} 类型形参：T就是一个类型形参，形参具体是什么类型取决于传进来什么类型\n类型约束：int | float64构成了一个类型约束，这个类型约束内规定了哪些类型是允许的，约束了类型形参的类型范围\n类型实参：Sum[int](1,2)，手动指定了int类型，int就是类型实参。\n泛型结构 1//切片 2type GenericSlice[T int | int32 | int64] []T 3GenericSlice[int]{1, 2, 3} //使用时就不能省略掉类型实参 反射reflect Valueof 和 Typeof\n1str := \u0026#34;hello world!\u0026#34; 2//获取变量的完整类型信息_会指出是那个包里面的某个类型 3reflectType := reflect.TypeOf(str) 4//获取变量的基本类型信息 5reflectType := reflect.TypeOf(str).Kind() 6//获取数据结构所存储的元素类型，必须是指针，切片，数组，通道，映射表其中之一 7reflectType := reflect.TypeOf(str).Elem() 8//获取对应类型所占的字节大小 9reflect.TypeOf(0).Size() 10 11//获取值 12reflectValue := reflect.ValueOf(str) 13//获取反射值原有的值 14func (v Value) Interface() (i any) 15//设置值 16func (v Value) Set(x Value) 函数反射和调用 1func Max(a, b int) int { 2 if a \u0026gt; b { 3 return a 4 } 5 return b 6} 7 8func main() { 9 rType := reflect.TypeOf(Max) 10 // 输出函数名称,字面量函数的类型没有名称 11 fmt.Println(rType.Name()) 12 // 输出参数，返回值的数量 13 fmt.Println(rType.NumIn(), rType.NumOut()) 14 rParamType := rType.In(0) 15 // 输出第一个参数的类型 16 fmt.Println(rParamType.Kind()) 17 rResType := rType.Out(0) 18 // 输出第一个返回值的类型 19 fmt.Println(rResType.Kind()) 20 21 22 // 获取函数的反射值 23 rType := reflect.ValueOf(Max) 24 // 传入参数数组 25 rResValue := rType.Call([]reflect.Value{reflect.ValueOf(18), reflect.ValueOf(50)}) 26 for _, value := range rResValue { 27 fmt.Println(value.Interface()) 28 } 29} 文件操作 go1.16之后 ioutil 包被迁移到了 io 和 os 包中\nGo文件操作的基础数据类型支持是 []byte\n打开 常见的两种打开文件的方式是使用os包提供的两个函数，Open函数返回值一个文件指针和一个错误，\n1func Open(文件名 string) (*File, error) 后者OpenFile能够提供更加细粒度的控制，实际上Open函数就是对OpenFile函数的一个简单封装。\n1func OpenFile(name string, flag int, perm FileMode) (*File, error) 先来介绍第一种使用方法，直接提供对应的文件名即可，代码如下\n网络编程 端口分类\n0：保留端口号\n1-1024：固定端口\n22：SSH远程登录协议 23：telnet使用 24：ftp使用 25：smtp服务使用 80：iis使用 7：echo使用\nTCP编程 **TCP协议： **传输控制协议/网际协议，是一种面向连接（连接导向）的、可靠的、基于字节流的传输层通信协议。一个TCP服务端可以同时连接很多个客户端\nTCP服务端程序的处理流程：\n监听端口 接收客户端请求建立链接 创建goroutine处理链接。 1//设置协议和监听端口 2listen, err := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;127.0.0.1:20000\u0026#34;) 3 4//建立链接 5conn, err := listen.Accept() 6 7//发送数据 8conn.Write([]byte(str)) 9 10//关闭链接 11conn.Close() TCP客户端进行TCP通信的流程\n建立与服务端的链接 进行数据收发 关闭链接 1//创建链接 返回一个Conn接口对象 对 2conn, err := net.Dial(\u0026#34;tcp\u0026#34;, \u0026#34;127.0.0.1:20000\u0026#34;) UDP编程 **UDP协议：**用户数据报协议，一种无连接的传输层协议，不需要建立连接就能直接进行数据发送和接收，属于不可靠的、没有时序的通信，但是UDP协议的实时性比较好，通常用于视频直播相关领域。\nUDP服务端\n1//创建链接 2listen, err := net.ListenUDP(\u0026#34;udp\u0026#34;, \u0026amp;net.UDPAddr{ 3\tIP: net.IPv4(0, 0, 0, 0), 4\tPort: 30000, 5}) \u0026quot;udp\u0026quot; ：指定网络类型，可以是\u0026quot;udp\u0026quot;, \u0026quot;udp4\u0026quot;, 或 \u0026quot;udp6\u0026quot;，\nnet.UDPAddr结构体包含以下字段：\nIP: 监听的本地IP地址。在这里，net.IPv4(0, 0, 0, 0)表示0.0.0.0，即监听所有可用的网络接口（可以接收来自任何本地IP地址的数据）。 Port: 监听的端口号，这里指定为30000。 Zone: 适用于IPv6的作用域标识符，这里没有使用，可以忽略。 1//接收数据 2n, addr, err := listen.ReadFromUDP(data[:]) 3// 发送数据 4_, err = listen.WriteToUDP(data[:n], addr) 5//关闭链接 6listen.Close() UDP客户端\n1//创建一个UDP链接 2socket, err := net.DialUDP(\u0026#34;udp\u0026#34;, nil, \u0026amp;net.UDPAddr{ 3\tIP: net.IPv4(0, 0, 0, 0), 4\tPort: 30000, 5}) net.DialUDP(\u0026quot;udp\u0026quot;, nil, \u0026amp;net.UDPAddr{...}):\nnet.DialUDP是net包中的一个函数，用于创建并返回一个UDP连接（*net.UDPConn）。 第一个参数\u0026quot;udp\u0026quot;指定了网络类型，可以是\u0026quot;udp\u0026quot;, \u0026quot;udp4\u0026quot;, 或 \u0026quot;udp6\u0026quot;，这里指定的是\u0026quot;udp\u0026quot;，表示使用UDP协议。 nil:\n第二个参数是本地地址（laddr），可以指定本地IP地址和端口。如果传递nil，表示让系统自动选择一个本地地址和端口。 \u0026amp;net.UDPAddr{...}:\n第三个参数是远程地址（raddr），是一个指向net.UDPAddr结构体的指针，用于指定远程服务器的IP地址和端口。\nnet.UDPAddr\n结构体包含三个字段：\nIP: 远程服务器的IP地址。在这里使用net.IPv4(0, 0, 0, 0)表示任意IP地址，即所有可用的网络接口。 Port: 远程服务器的端口号，这里指定为30000。 Zone: 用于IPv6地址的作用域标识符，这里没有使用，可以忽略。 1//发送数据 2_, err = socket.Write(sendData) 3//接受数据 4n, remoteAddr, err := socket.ReadFromUDP(data) TCP粘包 客户端不间断分10次发送的数据，在服务端并没有成功的输出10次，而是多条数据“粘”到了一起。\n为什么出现粘包 主要原因就是tcp数据传递模式是流模式，在保持长连接的时候可以进行多次的收和发。“粘包”可发生在发送端也可发生在接收端：\n由Nagle算法造成的发送端的粘包：Nagle算法是一种改善网络传输效率的算法。简单来说就是当我们提交一段数据给TCP发送时，TCP并不立刻发送此段数据，而是等待一小段时间看看在等待期间是否还有要发送的数据，若有则会一次把这两段数据发送出去。 接收端接收不及时造成的接收端粘包：TCP会把接收到的数据存在自己的缓冲区中，然后通知应用层取数据。当应用层由于某些原因不能及时的把TCP的数据取出来，就会造成TCP缓冲区中存放了几段数据。 解决办法 可以自己定义一个协议，比如数据包的前4个字节为包头，里面存储的是发送的数据的长度。\n常用标准库 fmt Print 打印输出 1func Print(a ...interface{}) (n int, err error)\t//直接输出 2func Printf(format string, a ...interface{}) (n int, err error)//格式化输出 3func Println(a ...interface{}) (n int, err error)//输出一行 Fprint 向 io.Writer 中输出 1func Fprint(w io.Writer, a ...interface{}) (n int, err error) 2func Fprintf(w io.Writer, format string, a ...interface{}) (n int, err error) 3func Fprintln(w io.Writer, a ...interface{}) (n int, err error) Sprint 返回字符串 1func Sprint(a ...interface{}) string 2func Sprintf(format string, a ...interface{}) string 3func Sprintln(a ...interface{}) string Errorf 返回包含格式化字符串的错误 1func Errorf(format string, a ...interface{}) error Scan 将输入数据读入到参数列表中，返回成功扫描的数据个数和遇到的任何错误。 1func Scan(a ...interface{}) (n int, err error) //用空格分开 2func Scanf(format string, a ...interface{}) (n int, err error)//格式化读入 3func Scanln(a ...interface{}) (n int, err error) //遇到换行时才停止扫描 Fscan 从io.Reader中读取数据。 1func Fscan(r io.Reader, a ...interface{}) (n int, err error) 2func Fscanln(r io.Reader, a ...interface{}) (n int, err error) 3func Fscanf(r io.Reader, format string, a ...interface{}) (n int, err error) Sscan 从指定字符串中读取数据 1func Sscan(str string, a ...interface{}) (n int, err error) 2func Sscanln(str string, a ...interface{}) (n int, err error) 3func Sscanf(str string, format string, a ...interface{}) (n int, err error) time 时间操作 1func (t Time) Add(d Duration) Time //时间+时间间隔 2func (t Time) Sub(u Time) Duration //求两个时间之间的差值 3func (t Time) Equal(u Time) bool //判断两个时间是否相同，会考虑时区的影响 4func (t Time) Before(u Time) bool //t代表的时间点在u之前，返回真 5func (t Time) After(u Time) bool //t代表的时间点在u之后，返回真 定时器 1Time.Tick(时间间隔) //定时器 返回一个channel，这个channel每隔一段时间会被读出 时间按格式化\n12006年1月2号15点04分 2 fmt.Println(now.Format(\u0026#34;2006-01-02 15:04:05.000 Mon Jan\u0026#34;)) 3 // 12小时制 4 fmt.Println(now.Format(\u0026#34;2006-01-02 03:04:05.000 PM Mon Jan\u0026#34;)) 5 fmt.Println(now.Format(\u0026#34;2006/01/02 15:04\u0026#34;)) 6 fmt.Println(now.Format(\u0026#34;15:04 2006/01/02\u0026#34;)) 7 fmt.Println(now.Format(\u0026#34;2006/01/02\u0026#34;)) IO操作 终端操作底层原理 终端其实是一个文件，相关实例如下：\nos.Stdin：标准输入的文件实例，类型为*File os.Stdout：标准输出的文件实例，类型为*File os.Stderr：标准错误输出的文件实例，类型为*File 1//以文件的方式操作终端 2func main() { 3 var buf [16]byte 4 os.Stdin.Read(buf[:]) 5 os.Stdin.WriteString(string(buf[:])) 6} 文件操作 func Create(name string) (file *File, err Error) 根据提供的文件名创建新的文件，返回一个文件对象，默认权限是0666 func NewFile(fd uintptr, name string) *File\n根据文件描述符创建相应的文件，返回一个文件对象 func Open(name string) (file *File, err Error) 只读方式打开一个名称为name的文件 func OpenFile(name string, flag int, perm uint32) (file *File, err Error) 打开名称为name的文件，flag是打开的方式，只读、读写等，perm是权限 func (file *File) Write(b []byte) (n int, err Error)\n写入byte类型的信息到文件 func (file *File) WriteAt(b []byte, off int64) (n int, err Error)\n在指定位置开始写入byte类型的信息 func (file *File) WriteString(s string) (ret int, err Error) 写入string信息到文件 func (file *File) Read(b []byte) (n int, err Error) 读取数据到b中 func (file *File) ReadAt(b []byte, off int64) (n int, err Error) 从off开始读取数据到b中 func Remove(name string) Error 删除文件名为name的文件 go web编程 hello word 1func main() { 2\thttp.HandleFunc(\u0026#34;/\u0026#34;, func(w http.ResponseWriter, r *http.Request) { 3\tw.Write([]byte(\u0026#34;Hello World\u0026#34;)) 4\t}) 5\thttp.ListenAndServe(\u0026#34;:8080\u0026#34;, nil) 6} 创建 web server 1// 第一个参数为监听地址，第二个参数为handle 2http.ListenAndServe(\u0026#34;:8080\u0026#34;, nil) 3 4//方法二 通过结构体创建，会更加灵活 5server := \u0026amp;http.Server{ 6 Addr: \u0026#34;:8080\u0026#34;, 7\tHandler: nil, 8} 9server.ListenAndServe() 10 11如果想支持https 使用 ListenAndServeTLS方法 ","permalink":"http://localhost:1313/posts/golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","summary":"\u003ch1 id=\"序言\"\u003e序言\u003c/h1\u003e\n\u003cp\u003e内存管理主要包含两个动作：分配和释放。逃逸分析就是服务于内存分配的，而内存的释放有GC负责\u003c/p\u003e\n\u003ch2 id=\"逃逸分析\"\u003e逃逸分析\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e基本数据类型一般来说分配在栈区，编译器存在一个逃逸分析\u003c/p\u003e","title":"GoLang学习笔记"},{"content":"安装 安装goctl\ngo install github.com/zeromicro/go-zero/tools/goctl@latest 使用 goctl测试安装是否成功\n安装组件\ngoctl env check --install --verbose --force\ngo-zero微服务框架下的代码生成工具。使用goctl可显著提升开发效率，让开发人员将时间重点放在业务开发上，其功能有\napi服务生成\nrpc服务生成\nmodel代码生成\n模板管理\n安装protoc \u0026amp; protoc-gen-go\ngoctl env check -i -f --verbose\n快速创建 api 服务\ngoctl api new api\nETCD Etcd是一个高可用的分布式键值存储系统，主要用于共享配置信息和服务发现。它采用Raft一致性算法来保证数据的强一致性，并且支持对数据进行监视和更新。 可以理解为加强版的 redis ，比 redis 的数据可靠性更强\n主要是用于微服务的配置中心，服务发现\n基本命令 // 设置或更新值\retcdctl put name 张三\r// 获取值\retcdctl get name\r// 只要value\retcdctl get name --print-value-only\r// 获取name前缀的键值对\retcdctl get --prefix name\r// 删除键值对\retcdctl del name\r// 监听键的变化\retcdctl watch name 微服务拆分原则 创业型项目使用单体架构、大型项目使用微服务架构，避免后续拆分麻烦\n拆分目标 ​\t**高内聚:**每个微服务的职责要尽量单一，包含的业务相互关联度高、完整度高。\n​\t**低耦合:**每个微服务的功能要相对独立，尽量减少对其它微服务的依赖。\n拆分原则 ​\t**纵向拆分:**按照业务模块来拆分\n​\t**横向拆分:**抽取公共服务，提高复用性\n","permalink":"http://localhost:1313/posts/go-zero%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","summary":"\u003ch1 id=\"安装\"\u003e安装\u003c/h1\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e安装goctl\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ego install github.com/zeromicro/go-zero/tools/goctl@latest\u003c/code\u003e 使用 \u003ccode\u003egoctl\u003c/code\u003e测试安装是否成功\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e安装组件\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003egoctl env check --install --verbose --force\u003c/code\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003ego-zero微服务框架下的代码生成工具。使用goctl可显著提升开发效率，让开发人员将时间重点放在业务开发上，其功能有\u003c/p\u003e","title":"Go Zero学习笔记"},{"content":"Git学习笔记 配置和初始化 参数：\nLocal：本地配置，只对本地仓库有效 golbal：全局配置，所有仓库生效 system：系统配置，对所有用户生效 //配置用户名\rgit config --global user.name \u0026#34;name\u0026#34;\r//配置邮箱\rgit config --global user.email \u0026#34;321321@outlook.com\u0026#34;\r//保存\rgit config --global --list 新建版本库 有两种方式，一种在本地创建仓库，一种从网上克隆仓库\n//在本地创建仓库\r//1、新建目录\rmkdir learn-git\r//2.新建仓库\rgit init 工作区域和文件状态 工作区域 工作区：.git所在的目录 暂存区：.git/index 临时存储区域，用于保存即将提交到git仓库的修改内容， 本地仓库：.git/objects 包含完整的项目历史和版本工具 文件状态 未跟踪：新创建还没有被Git管理起来的文件 未修改：已经被Git管理但是文件内容没有发生变化 已修改：已经修改过还没有添加到暂存区中的文件 已暂存：修改过后已经添加到暂存区中的文件 添加和提交文件 //新建仓库\rgit init\r//查看仓库状态\rgit status\r//添加到暂存区\rgit add\r//提交\rgit commit -m \u0026#34;提交参数信息\u0026#34; 回退版本——git reset命令 三种模式\ngit reset \u0026ndash;soft 回退到某个版本并且保留工作区和暂存区的所有修改内容 git reset \u0026ndash;hard 回退到某个版本并且丢弃工作区和暂存区的所有修改内容 git reset \u0026ndash;mixed 默认参数 回退到某个版本保留工作区丢弃暂存区 查看差异——git diff //比较工作区和暂存区的差异\rgit diff\r//比较工作区和仓库的差异\rgit diff HEAD\r//比较暂存区和仓库之间的差异\rgit diff --cached\r//比较版本差异\r//HEAD 指向最新提交节点\rgit diff \u0026#39;版本号1\u0026#39; \u0026#39;版本号2\u0026#39;\rgit diff \u0026#39;版本号1\u0026#39; HEAD\t//对比最新版本\rgit diff HEAD~ HEAD\t//HEAD~指向上一个版本\rgit diff HEAD^ HEAD\t//HEAD^指向上一个版本\rgit diff HEAD~2 HEAD\t//HEAD~2指向之前的两个版本\rgit diff HEAS~3 HEAD filename //只查看这个文件的差异 删除文件 //直接删除\r//使用这种删除只是删除工作区，暂存区中还没有删除，需要接着提交到暂存区然后提交到仓库才算删除\rrm filename\r//删除命令\r//同时删除工作区和暂存区\rgit rm filename\r//删除仓库中的文件并将这个文件放回暂存区\rgit rm --cached filename .gitignore 忽略文件 git会忽略在.gitignore中列出的文件\n文件的匹配方式跟正则表达式很像\n在这节课中用到的一些命令\n//将工作区中的内容直接提交到仓库\rgit commit -am \u0026#34;massage\u0026#34;\r//追加内容\recho \u0026#34;text\u0026#34; \u0026gt;\u0026gt; filename\r//新建目录\rmkdir temp\r//显示被Git追踪的文件\rgit ls-files\r//显示简短的文件状态\r1.?? 未跟踪\r2.M 已修改\r3.A 已添加暂存\r4.D 已删除\r5.R 重命名\r6.U 更新未合并\rgit status -s SSH配置和克隆仓库 //生成SSH密钥\rssh-keygen -t rsa -b 4096\r//克隆仓库\rgit clone \u0026#39;SSH地址\u0026#39;\r//将文件推送到github上 需要在github上添加SSH的公钥\rgit push 回到根目录\n如果不是第一次创建密钥则执行以下操作\n输入SSH文件名再回车 添加config文件，并在文件中添加\nHost github.com\rHostName github.com\rPreferredAuthentications publickey\rIdentityFile ~/.ssh/name 关联本地仓库和远程仓库 //添加远程仓库\rgit remoter add \u0026#39;仓库别名\u0026#39; \u0026#39;仓库地址\u0026#39;\rgit push -u \u0026#39;远程仓库名\u0026#39; \u0026#39;分支名\u0026#39;\r//列出别名对应的远程仓库\rgit remote -v\r//与本地仓库关联\rgit push -u \u0026#39;远程仓库别名\u0026#39; 分支名:分支名\r//拉取远程仓库内容与本地仓库合并\r//拉去之后会自动执行一次合并操作\rgit pull \u0026#39;远程仓库名\u0026#39; \u0026#39;远程分支名\u0026#39;:\u0026#39;本地分支名\u0026#39;\r//获取远程仓库的修改，不会自动合并到本地仓库中\rgit fetch 分支和基本操作 使用分支名+序号命名文件\n使用分支名+冒号+序号的方式编写提交记录\n新建分支 git branch 分支名 切换分支 git switch 分支名 合并分支 //将指定分支合并到当前所在分支\rgit merge 分支名 删除分支 git branch -d 分支名\r//如果分支没有合并\rgit branch -D 分支名 回退和 rebase 在rebase中，每个分支都有一个指针，指向当前分支的最新提交记录，在执行rebase时，git会先找到当前分支和目标分支的共同祖先，在把当前分支从共同祖先到最新提交记录的所有提交都移动到目标分支的最新提交后面\nRebase 和 Merge有什么区别该如何区分使用 Merge\n优点：不会破坏原分支的提交历史，方便回溯和查看 缺点：会产生额外的提交节点，分支图比较复杂 Rebase\n优点：不会新增额外的提交记录，形成线性历史，直观干净 缺点：会改变提交历史，改变了当前分支 branch out 的节点 分支管理和工作流模型\n","permalink":"http://localhost:1313/posts/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","summary":"\u003ch1 id=\"git学习笔记\"\u003eGit学习笔记\u003c/h1\u003e\n\u003ch2 id=\"配置和初始化\"\u003e配置和初始化\u003c/h2\u003e\n\u003cp\u003e参数：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eLocal：本地配置，只对本地仓库有效\u003c/li\u003e\n\u003cli\u003egolbal：全局配置，所有仓库生效\u003c/li\u003e\n\u003cli\u003esystem：系统配置，对所有用户生效\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-git\" data-lang=\"git\"\u003e//配置用户名\r\ngit config --global user.name \u0026#34;name\u0026#34;\r\n//配置邮箱\r\ngit config --global user.email \u0026#34;321321@outlook.com\u0026#34;\r\n//保存\r\ngit config --global --list\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"新建版本库\"\u003e新建版本库\u003c/h2\u003e\n\u003cp\u003e有两种方式，一种在本地创建仓库，一种从网上克隆仓库\u003c/p\u003e","title":"Git学习笔记"},{"content":"分布式key-value存储系统，用于配置共享和服务的注册和发现。\n安装 go get go.etcd.io/etcd/client/v3 使用 创建链接 1cli, err := clientv3.New(clientv3.Config{ 2 Endpoints: []string{\u0026#34;127.0.0.1:2379\u0026#34;}, 3 DialTimeout: 5 * time.Second, 4}) put和get操作 1//put 2ctx, cancel := context.WithTimeout(context.Background(), time.Second) 3_, err = cli.Put(ctx, \u0026#34;lmh\u0026#34;, \u0026#34;lmh\u0026#34;) 4cancel() 5 6//get 7ctx, cancel = context.WithTimeout(context.Background(), time.Second) 8resp, err := cli.Get(ctx, \u0026#34;lmh\u0026#34;) 9cancel() watch操作 1//获取未来更改通知 2// watch key:lmh change 3rch := cli.Watch(context.Background(), \u0026#34;lmh\u0026#34;) // \u0026lt;-chan WatchResponse 4for wresp := range rch { 5\tfor _, ev := range wresp.Events { 6\tfmt.Printf(\u0026#34;Type: %s Key:%s Value:%s\\n\u0026#34;, ev.Type, ev.Kv.Key, ev.Kv.Value) 7\t} 8} lease租约 1// 创建一个5秒的租约 2resp, err := cli.Grant(context.TODO(), 5) 3 4// 5秒钟之后, /lmh/ 这个key就会被移除 5 _, err = cli.Put(context.TODO(), \u0026#34;/lmh/\u0026#34;, \u0026#34;lmh\u0026#34;, clientv3.WithLease(resp.ID)) keepAlive 1_, err = cli.Put(context.TODO(), \u0026#34;/lmh/\u0026#34;, \u0026#34;lmh\u0026#34;, clientv3.WithLease(resp.ID)) 2 3// the key \u0026#39;foo\u0026#39; will be kept forever 4ch, kaerr := cli.KeepAlive(context.TODO(), resp.ID) ","permalink":"http://localhost:1313/posts/etcd%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","summary":"\u003cp\u003e分布式key-value存储系统，用于配置共享和服务的注册和发现。\u003c/p\u003e\n\u003ch2 id=\"安装\"\u003e安装\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003ego get go.etcd.io/etcd/client/v3 \u003c/code\u003e\u003c/p\u003e\n\u003ch2 id=\"使用\"\u003e使用\u003c/h2\u003e\n\u003ch3 id=\"创建链接\"\u003e创建链接\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-go\" data-lang=\"go\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e1\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nx\"\u003ecli\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nx\"\u003eerr\u003c/span\u003e \u003cspan class=\"o\"\u003e:=\u003c/span\u003e \u003cspan class=\"nx\"\u003eclientv3\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eNew\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003eclientv3\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003eConfig\u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e2\u003c/span\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"nx\"\u003eEndpoints\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e   \u003cspan class=\"p\"\u003e[]\u003c/span\u003e\u003cspan class=\"kt\"\u003estring\u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;127.0.0.1:2379\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e},\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e3\u003c/span\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"nx\"\u003eDialTimeout\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"mi\"\u003e5\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"nx\"\u003etime\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003eSecond\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e4\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e})\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"put和get操作\"\u003eput和get操作\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-go\" data-lang=\"go\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e1\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e//put\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e2\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"nx\"\u003ectx\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nx\"\u003ecancel\u003c/span\u003e \u003cspan class=\"o\"\u003e:=\u003c/span\u003e \u003cspan class=\"nx\"\u003econtext\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eWithTimeout\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003econtext\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eBackground\u003c/span\u003e\u003cspan class=\"p\"\u003e(),\u003c/span\u003e \u003cspan class=\"nx\"\u003etime\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003eSecond\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e3\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nx\"\u003e_\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nx\"\u003eerr\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003ecli\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003ePut\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003ectx\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;lmh\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;lmh\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e4\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nf\"\u003ecancel\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e5\u003c/span\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e6\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e//get\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e7\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"nx\"\u003ectx\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nx\"\u003ecancel\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003econtext\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eWithTimeout\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003econtext\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eBackground\u003c/span\u003e\u003cspan class=\"p\"\u003e(),\u003c/span\u003e \u003cspan class=\"nx\"\u003etime\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003eSecond\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e8\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nx\"\u003eresp\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nx\"\u003eerr\u003c/span\u003e \u003cspan class=\"o\"\u003e:=\u003c/span\u003e \u003cspan class=\"nx\"\u003ecli\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eGet\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003ectx\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;lmh\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e9\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nf\"\u003ecancel\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"watch操作\"\u003ewatch操作\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-go\" data-lang=\"go\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e1\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e//获取未来更改通知\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e2\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// watch key:lmh change\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e3\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"nx\"\u003erch\u003c/span\u003e \u003cspan class=\"o\"\u003e:=\u003c/span\u003e \u003cspan class=\"nx\"\u003ecli\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eWatch\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003econtext\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eBackground\u003c/span\u003e\u003cspan class=\"p\"\u003e(),\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;lmh\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"c1\"\u003e// \u0026lt;-chan WatchResponse\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e4\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"nx\"\u003ewresp\u003c/span\u003e \u003cspan class=\"o\"\u003e:=\u003c/span\u003e \u003cspan class=\"k\"\u003erange\u003c/span\u003e \u003cspan class=\"nx\"\u003erch\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e5\u003c/span\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"nx\"\u003e_\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nx\"\u003eev\u003c/span\u003e \u003cspan class=\"o\"\u003e:=\u003c/span\u003e \u003cspan class=\"k\"\u003erange\u003c/span\u003e \u003cspan class=\"nx\"\u003ewresp\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003eEvents\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e6\u003c/span\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"nx\"\u003efmt\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003ePrintf\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;Type: %s Key:%s Value:%s\\n\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nx\"\u003eev\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003eType\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nx\"\u003eev\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003eKv\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003eKey\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nx\"\u003eev\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003eKv\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003eValue\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e7\u003c/span\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e8\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"lease租约\"\u003elease租约\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-go\" data-lang=\"go\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e1\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// 创建一个5秒的租约\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e2\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"nx\"\u003eresp\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nx\"\u003eerr\u003c/span\u003e \u003cspan class=\"o\"\u003e:=\u003c/span\u003e \u003cspan class=\"nx\"\u003ecli\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eGrant\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003econtext\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eTODO\u003c/span\u003e\u003cspan class=\"p\"\u003e(),\u003c/span\u003e \u003cspan class=\"mi\"\u003e5\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e3\u003c/span\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e4\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// 5秒钟之后, /lmh/ 这个key就会被移除\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e5\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e \u003cspan class=\"nx\"\u003e_\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nx\"\u003eerr\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003ecli\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003ePut\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003econtext\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eTODO\u003c/span\u003e\u003cspan class=\"p\"\u003e(),\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;/lmh/\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;lmh\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nx\"\u003eclientv3\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eWithLease\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003eresp\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003eID\u003c/span\u003e\u003cspan class=\"p\"\u003e))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"keepalive\"\u003ekeepAlive\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-go\" data-lang=\"go\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e1\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nx\"\u003e_\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nx\"\u003eerr\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003ecli\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003ePut\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003econtext\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eTODO\u003c/span\u003e\u003cspan class=\"p\"\u003e(),\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;/lmh/\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;lmh\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nx\"\u003eclientv3\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eWithLease\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003eresp\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003eID\u003c/span\u003e\u003cspan class=\"p\"\u003e))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e2\u003c/span\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e3\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// the key \u0026#39;foo\u0026#39; will be kept forever\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e4\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"nx\"\u003ech\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nx\"\u003ekaerr\u003c/span\u003e \u003cspan class=\"o\"\u003e:=\u003c/span\u003e \u003cspan class=\"nx\"\u003ecli\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eKeepAlive\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003econtext\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eTODO\u003c/span\u003e\u003cspan class=\"p\"\u003e(),\u003c/span\u003e \u003cspan class=\"nx\"\u003eresp\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003eID\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"ETCD学习笔记"},{"content":"六种工作模式 simple简单模式 消费者拿走一个mq删除一个，无法保证消费者正确处理数据\n一般用来聊天\nwork工作模式 多个消费者共同争抢争抢当前的消息队列内容，谁先拿到谁负责消费消息\n用来红包\npublish/subscribe发布订阅 生产者将消息发送给交换机，由交换机发送信息给每个消息队列，对应消息队列的消费者拿到消息进行消费\nrouting路由模式 在发布订阅模式上增加了路由规则，只将消息发送给匹配规则的消息队列\ntopic 主题模式 交换机根据key的模糊匹配规则，匹配到对应的队列\n操作mq 初始化库 1import ( 2\t\u0026#34;log\u0026#34; 3\t\u0026#34;github.com/streadway/amqp\u0026#34; 4) 5 6// MQURL 格式 amqp://账号：密码@rabbitmq服务器地址：端口号/vhost (默认是5672端口) 7// 端口可在 /etc/rabbitmq/rabbitmq-env.conf 配置文件设置，也可以启动后通过netstat -tlnp查看 8const MQURL = \u0026#34;amqp://admin:huan91uncc@172.21.138.131:5672/\u0026#34; 9 10type RabbitMQ struct { 11\tConn *amqp.Connection 12\tChannel *amqp.Channel 13\t// 队列名称 14\tQueueName string 15\t// 交换机 16\tExchange string 17\t// routing Key 18\tRoutingKey string 19\t//MQ链接字符串 20\tMqurl string 21} 22 23// 创建结构体实例 24func NewRabbitMQ(queueName, exchange, routingKey string) *RabbitMQ { 25\trabbitMQ := RabbitMQ{ 26\tQueueName: queueName, 27\tExchange: exchange, 28\tRoutingKey: routingKey, 29\tMqurl: MQURL, 30\t} 31\tvar err error 32\t//创建rabbitmq连接 33\trabbitMQ.Conn, err = amqp.Dial(rabbitMQ.Mqurl) 34\tcheckErr(err, \u0026#34;创建连接失败\u0026#34;) 35 36\t//创建Channel 37\trabbitMQ.Channel, err = rabbitMQ.Conn.Channel() 38\tcheckErr(err, \u0026#34;创建channel失败\u0026#34;) 39 40\treturn \u0026amp;rabbitMQ 41 42} 43 44// 释放资源,建议NewRabbitMQ获取实例后 配合defer使用 45func (mq *RabbitMQ) ReleaseRes() { 46\tmq.Conn.Close() 47\tmq.Channel.Close() 48} 49 50func checkErr(err error, meg string) { 51\tif err != nil { 52\tlog.Fatalf(\u0026#34;%s:%s\\n\u0026#34;, meg, err) 53\t} 54} 生产者 1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;mq/rabbitMq\u0026#34; 6 7\t\u0026#34;github.com/streadway/amqp\u0026#34; 8) 9 10//生产者发布流程 11func main() { 12\t// 初始化mq 13\tmq := rabbitMq.NewRabbitMQ(\u0026#34;queue_publisher\u0026#34;, \u0026#34;exchange_publisher\u0026#34;, \u0026#34;key1\u0026#34;) 14\tdefer mq.ReleaseRes() // 完成任务释放资源 15 16\t// 1.声明队列 17\t/* 18\t如果只有一方声明队列，可能会导致下面的情况： 19\ta)消费者是无法订阅或者获取不存在的MessageQueue中信息 20\tb)消息被Exchange接受以后，如果没有匹配的Queue，则会被丢弃 21 22\t为了避免上面的问题，所以最好选择两方一起声明 23\tps:如果客户端尝试建立一个已经存在的消息队列，Rabbit MQ不会做任何事情，并返回客户端建立成功的 24\t*/ 25\t_, err := mq.Channel.QueueDeclare( // 返回的队列对象内部记录了队列的一些信息，这里没什么用 26\tmq.QueueName, // 队列名 27\ttrue, // 是否持久化 28\tfalse, // 是否自动删除(前提是至少有一个消费者连接到这个队列，之后所有与这个队列连接的消费者都断开时，才会自动删除。注意：生产者客户端创建这个队列，或者没有消费者客户端与这个队列连接时，都不会自动删除这个队列) 29\tfalse, // 是否为排他队列（排他的队列仅对“首次”声明的conn可见[一个conn中的其他channel也能访问该队列]，conn结束后队列删除） 30\tfalse, // 是否阻塞 31\tnil, //额外属性（我还不会用） 32\t) 33\tif err != nil { 34\tfmt.Println(\u0026#34;声明队列失败\u0026#34;, err) 35\treturn 36\t} 37 38\t// 2.声明交换器 39\terr = mq.Channel.ExchangeDeclare( 40\tmq.Exchange, //交换器名 41\t\u0026#34;topic\u0026#34;, //exchange type：一般用fanout、direct、topic 42\ttrue, // 是否持久化 43\tfalse, //是否自动删除（自动删除的前提是至少有一个队列或者交换器与这和交换器绑定，之后所有与这个交换器绑定的队列或者交换器都与此解绑） 44\tfalse, //设置是否内置的。true表示是内置的交换器，客户端程序无法直接发送消息到这个交换器中，只能通过交换器路由到交换器这种方式 45\tfalse, // 是否阻塞 46\tnil, // 额外属性 47\t) 48\tif err != nil { 49\tfmt.Println(\u0026#34;声明交换器失败\u0026#34;, err) 50\treturn 51\t} 52 53\t// 3.建立Binding(可随心所欲建立多个绑定关系) 54\terr = mq.Channel.QueueBind( 55\tmq.QueueName, // 绑定的队列名称 56\tmq.RoutingKey, // bindkey 用于消息路由分发的key 57\tmq.Exchange, // 绑定的exchange名 58\tfalse, // 是否阻塞 59\tnil, // 额外属性 60\t) 61\t// err = mq.Channel.QueueBind( 62\t// mq.QueueName, // 绑定的队列名称 63\t// \u0026#34;routingkey2\u0026#34;, // bindkey 用于消息路由分发的key 64\t// mq.Exchange, // 绑定的exchange名 65\t// false, // 是否阻塞 66\t// nil, // 额外属性 67\t// ) 68\tif err != nil { 69\tfmt.Println(\u0026#34;绑定队列和交换器失败\u0026#34;, err) 70\treturn 71\t} 72 73\t// 4.发送消息 74\tmq.Channel.Publish( 75\tmq.Exchange, // 交换器名 76\tmq.RoutingKey, // routing key 77\tfalse, // 是否返回消息(匹配队列)，如果为true, 会根据binding规则匹配queue，如未匹配queue，则把发送的消息返回给发送者 78\tfalse, // 是否返回消息(匹配消费者)，如果为true, 消息发送到queue后发现没有绑定消费者，则把发送的消息返回给发送者 79\tamqp.Publishing{ // 发送的消息，固定有消息体和一些额外的消息头，包中提供了封装对象 80\tContentType: \u0026#34;text/plain\u0026#34;, // 消息内容的类型 81\tBody: []byte(\u0026#34;hello jochen\u0026#34;), // 消息内容 82\t}, 83\t) 84} 消费者 1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;mq/rabbitMq\u0026#34; 6) 7 8// 消费者订阅 9func main() { 10\t// 初始化mq 11\tmq := rabbitMq.NewRabbitMQ(\u0026#34;queue_publisher\u0026#34;, \u0026#34;exchange_publisher\u0026#34;, \u0026#34;key1\u0026#34;) 12\tdefer mq.ReleaseRes() // 完成任务释放资源 13 14\t// 1.声明队列（两端都要声明，原因在生产者处已经说明） 15\t_, err := mq.Channel.QueueDeclare( // 返回的队列对象内部记录了队列的一些信息，这里没什么用 16\tmq.QueueName, // 队列名 17\ttrue, // 是否持久化 18\tfalse, // 是否自动删除(前提是至少有一个消费者连接到这个队列，之后所有与这个队列连接的消费者都断开时，才会自动删除。注意：生产者客户端创建这个队列，或者没有消费者客户端与这个队列连接时，都不会自动删除这个队列) 19\tfalse, // 是否为排他队列（排他的队列仅对“首次”声明的conn可见[一个conn中的其他channel也能访问该队列]，conn结束后队列删除） 20\tfalse, // 是否阻塞 21\tnil, // 额外属性（我还不会用） 22\t) 23\tif err != nil { 24\tfmt.Println(\u0026#34;声明队列失败\u0026#34;, err) 25\treturn 26\t} 27 28\t// 2.从队列获取消息（消费者只关注队列）consume方式会不断的从队列中获取消息 29\tmsgChanl, err := mq.Channel.Consume( 30\tmq.QueueName, // 队列名 31\t\u0026#34;\u0026#34;, // 消费者名，用来区分多个消费者，以实现公平分发或均等分发策略 32\ttrue, // 是否自动应答 33\tfalse, // 是否排他 34\tfalse, // 是否接收只同一个连接中的消息，若为true，则只能接收别的conn中发送的消息 35\ttrue, // 队列消费是否阻塞 36\tnil, // 额外属性 37\t) 38\tif err != nil { 39\tfmt.Println(\u0026#34;获取消息失败\u0026#34;, err) 40\treturn 41\t} 42 43\tfor msg := range msgChanl { 44\t// 这里写你的处理逻辑 45\t// 获取到的消息是amqp.Delivery对象，从中可以获取消息信息 46\tfmt.Println(string(msg.Body)) 47\t// msg.Ack(true) // 主动应答 48 49\t} 50 51} 高可用 开启持久化或配置合理的自动重试和死信队列、集群部署\n消息不被重复消费 保证每条数有自己的 全局 ID 可靠性 生产者丢失 发送消息前开启事务，失败自动回滚，从新发送 消费队列丢失 开始持久化 消费者丢失 手动确认消息 消息有序 入队有序\n","permalink":"http://localhost:1313/posts/rabbitmq%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","summary":"\u003ch1 id=\"六种工作模式\"\u003e六种工作模式\u003c/h1\u003e\n\u003ch2 id=\"simple简单模式\"\u003esimple简单模式\u003c/h2\u003e\n\u003cp\u003e消费者拿走一个mq删除一个，无法保证消费者正确处理数据\u003c/p\u003e\n\u003cp\u003e一般用来聊天\u003c/p\u003e\n\u003ch2 id=\"work工作模式\"\u003ework工作模式\u003c/h2\u003e\n\u003cp\u003e多个消费者共同争抢争抢当前的消息队列内容，谁先拿到谁负责消费消息\u003c/p\u003e\n\u003cp\u003e用来红包\u003c/p\u003e\n\u003ch2 id=\"publishsubscribe发布订阅\"\u003epublish/subscribe发布订阅\u003c/h2\u003e\n\u003cp\u003e生产者将消息发送给交换机，由交换机发送信息给每个消息队列，对应消息队列的消费者拿到消息进行消费\u003c/p\u003e","title":"RabbitMQ学习笔记"},{"content":"docker run 创建并运行一个容器，-d 让容器在后台运行\n\u0026ndash;name ：给容器起名字，必须唯一\n-p xxxx:yyyy ：xxxx宿主机端口，yyyy容器内端口\n-e key=value： 设置环境变量\n基础 常见命令 1下载镜像 2# docker pull 3 4查看已有的镜像 5# docker images 6 7删除镜像 8# docker rmi 9 10构建镜像 11# docker build 12 13保存到本地 14# docker save 15 16加载本地镜像 17# docker load 18 19将镜像推送到服务器 20# docker push 21 22创建并运行容器 23# docker run 24 25停止容器内部进程，容器还在 26# docker stop 27 28将容器内部停掉的进程再次启动起来 29# docker start 30 31查看当前容器运行状态 32# docker ps 33 -a 打印所有容器 34删除容器 35# docker rm 36 37查看日志 38# docker logs 39 40进入容器 41# docker exec 数据卷 是一个虚拟目录，是容器内目录与宿主机目录之间映射的桥梁\n当创建容器时，如果挂载了数据卷且数据卷不存在，会自动创建数据卷\n1在创建容器时加入-v参数就可以实现挂载 2# docker run …… -v 数据卷:容器内目录 …… 3 4创建数据卷 5# docker volume create 6 7查看所有数据卷 8# docker volume ls 9 10删除指定数据卷 11# docker volume rm 12 13查看指定数据卷 14# docker volume inspect 15 16清除数据卷 17# docker volume prune 本地目录挂载 在执行 docker run 时加入-v参数就可以实现挂载\n1# docker run -v 本地目录:容器内目录 本地目录必须以/ 或 ./ 开头，如果直接名称开头会被识别为数据卷而非本地目录\n-v mysql:/var/lib/mysql 会被识别为一个数据卷叫mysql -v ./mysql:/var/lib/mysql 会被识别为当前目录下的mysql目录 自定义镜像 镜像结构\n入口-Entrypoint : 镜像运行入口，一般是程序启动的脚本参数 层-Layer : 添加安装包、依赖、配置等，每次操作都形成新的一层 基础镜像-BaseImage : 应用依赖的系统函数库、环境、配置、文件等 Dockerfile\n一个文本文件，其中包含一个个的指令(Instruction)，用指令来说明要执行什么操作来构建镜像，常见指令如下\n指令 说明 示例 FROM 指定基础镜像 FROM centos:6 ENV 设置环境变量 ENV key value COPY 拷贝本地文件到镜像的指定目录 COPY ./xx.jar /tmp/app.jar RUN 执行Linux的shell命令，一般是安装过程的命令 RUN yum install gcc EXPOSE 指定容器运行时监听的端口 EXPOSE 8080 ENTRYPOINT 镜像中应用的启动命令，容器运行时调用 ENTRYPOINT java -jar xx.jar k8s 核心组件 node：一个物理机或虚拟机，在这上面可以运行一个或多个pod\npod：最小的调度单元，一个或者多个应用容器的组合，容器运行环境\nsvc：service 将一组pod封装成一个服务，使这个服务可以通过一个固定的入口来访问\nnode:port ：外部服务，在节点上开放一个端口，将这个端口映射到svc的ip地址和端口上\ningress：管理从集群外部访问集群内部服务的入口和方式，可以配置不同的转发规则，还可以配置域名，负载均衡，SSL证书\nConfigMap：将配置信息封装起来，在应用程序中读取和使用，配置信息都是明文的\nSecret：和ConfigMap类似，会将一些敏感信息封装起来，只是做了base64编码，需要配合k8s的其他安全机制使用\nVolumes：将持久化存储的资源挂载到集群中的本地磁盘上，或者挂载到集群外部的远程存储上\nDeployment：定义和管理应用程序的副本数量，当有副本发生故障，会自动创建新的副本，滚动更新是指可以定义和管理应用程序的更新策略，轻松升级应用程序的版本，不断用新的版本替换掉旧的版本\nStatefulSet：和Deployment类似，保证每个副本都有自己稳定的网络标识符和持久化存储\n架构 Master-Worker架构 Master-node负责管理整个集群，Worker-node负责应用程序和服务\nWorker-node 每个节点包含三个组件 kubelet、kube-proxy、container-runtime\ncontainer-runtime： 简单理解为一个运行容器的软件，负责拉去容器镜像，创建容器，启动或停止容器，所有的容器都需要使用容器运行时来运行\n常用的容器运行时有 Docker-Engine、Containerd、CRI-O、Mirantis Container Runtime\nkubelete： 管理和维护每个节点上的Pod，并确保他们按照预期运行，可以定期从api-server组件接收新的或者修改后的Pod规范，监控工作节点的运行情况，然后将这些信息汇报给apiserver\nkube-proxy： 负责为Pod对象提供网络代理和负载均衡服务\n通常情况下Kubernetes集群包含多个节点，这些节点之间通过Service来进行通信，这就需要一个负载均衡器来接收请求，然后将请求发送到不同的节点上完成负载均衡，该功能就是由 kube-proxy 负责\nMaster-node 4个基本组件：kube- apiserver、etcd、ControllerManager、Scheduler\nkube- apiserver 它负责提供Kubernetes集群的API接口服务，所有的组件都会通过这个接口来进行通信，还负责对所有资源对象的 增 删 改 查 等操作进行认证授权和访问控制。\nScheduler： 调度器，它负责监控集群中所有节点的资源使用情况，根据调度策略将Pod调度到合适的节点上运行\nController Manager： 管理集群中各种资源对象的状态\netcd： 高可用键值存储系统\nCloud Controller Manager：（如果用云服务商提供的Kubernetes集群会有这个东西） 云控制器管理器，是一个云平台相关的控制器，负责与云平台的 API 进行交互\nminikube 和 kubectl minikube ：轻量级k8s发行版，搭建k8s环境\nkubectl ：和集群环境进行交互的命令行工具\nmultipas常用命令\n# 查看帮助\rmultipass help\rmultipass help \u0026lt;command\u0026gt;\r# 创建⼀个名字叫做k3s的虚拟机\rmultipass launch --name k3s\r# 在虚拟机中执⾏命令\rmultipass exec k3s -- ls -l\r# 进⼊虚拟机并执⾏shell\rmultipass shell k3s\r# 查看虚拟机的信息\rmultipass info k3s\r# 停⽌虚拟机\rmultipass stop k3s\r# 启动虚拟机\rmultipass start k3s\r# 删除虚拟机\rmultipass delete k3s\r# 清理虚拟机\rmultipass purge\r# 查看虚拟机列表\rmultipass list\r# 创建一台虚拟机\rmultipass launch --name k3s --cpus 2 --memory 4G --disk 10G ","permalink":"http://localhost:1313/posts/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","summary":"\u003cp\u003edocker run 创建并运行一个容器，-d 让容器在后台运行\u003c/p\u003e\n\u003cp\u003e\u0026ndash;name ：给容器起名字，必须唯一\u003c/p\u003e\n\u003cp\u003e-p xxxx:yyyy ：xxxx宿主机端口，yyyy容器内端口\u003c/p\u003e\n\u003cp\u003e-e key=value： 设置环境变量\u003c/p\u003e","title":"Docker学习笔记"},{"content":"第一章—计算机系统概述 MAR 地址寄存器：用于寻址，位数对应存储单元的个数\nMDR 数据寄存器：位数和存储字长相等\n存储体由许多存储单元组成，每个存储单元包含若干存储元件，每个存储元件存储一位二进制代码。存储单元可存储一串二进制代码称这串代码为存储字，称这串代码的位数为存储字长。\nCPU和主存之间通过一组总线相连，总线中有地址、控制和数据三组信号线。MAR中的地址信息会直接送到地址线上，用于指向主存存储单元；控制线中的读/写信号线指出数据是从CPU写入主存还是从主存读出到CPU，根据读操作还是写操作来控制将MDR中的数据是直接送到数据线上，还是将数据线上的数据接收到MDR中。\n字长：计算机进行一次整数运算所能处理的二进制数据的位数，一般等于内部寄存器的大小，字长越长，计算机精度越高\n数据通路带宽：指数据总线一次能并线传输信息的位数。\n吞吐量：指系统在单位时间处理请求的数量。\n响应时间：用户向计算机发送一个请求，到收到结果的等待时间。\nCPU时钟周期：主频的倒数，CPU中最小的时间单位，执行指令的每个动作至少需要一个时钟周期\n主频( CPU时钟频率 )：机器内部主时钟的频率，主频越高，完成指令的一个执行步骤所用的时间越短\n主频通常以 Hz 为单位，1Hz表示每秒一次\nCPI：执行一条指令所需的时钟周期数。\nCPU执行时间：运行一个程序所花费的时间\nCPU执行时时间 = CPU时钟周期数 / 主频 = ( 指令条数 × CPI ) / 主频\nMIPS：每秒执行多少百万条指令\nMIPS = 指令条数 / (执行时间 × $10^{6}$) = 主频 / (CPI × $10^{6}$)\n描述文件大小时，K、M、G、T 通常用 2 的幂次表示，如 1Kb= $2^{10}$b； 描述速率、频率时，k、M、G、T 通常用 10 的幂次表示，如 1kb/s = $10^{3}$b/s 前者通常用大写 K，后者用小写 k\n字、字长、机器字长、指令字长、存储字长的区别和联系是什么?\n在通常所说的“某16 位或32位机器”中，16、32指的是字长，也称机器字长。所谓字长，通常是指CPU内部用于整数运算的数据通路的宽度，因此字长等于CPU内部用于整数运算的运算器位数和通用寄存器宽度，它反映了计算机处理信息的能力。字和字长的概念不同。字主用来表示被处理信息的单位，用来度量数据类型的宽度，如 x86 机器中将一个字定义为 16 位。 **指令字长:**一个指令字中包含的二进制代码的位数。 **存储字长:**一个存储单元存储的二进制代码的长度。 它们都必须是字节的整数倍。 指令字长一般取存储字长的整数倍，若指令字长等于存储字长的 2 倍，则需要 2 个访存周期来取出一条指令；若指令字长等于存储字长,则取指周期等于机器周期。\n第二章—数据的表示和运算 正数的原反补都一样\n负数反码为原码取反\n负数补码为原码取反加一\n移码为真值加偏移量\n标志位生成 （OF、SF、ZF、CF） OF：\n含义：有符号数的加减运算是否发生了溢出 OF = 1表示溢出\n计算方法：**最高位产生的进位与次高位产生的进位异或 异或：不同为1，相同为0\n对无符号数的加减无意义\nSF：\n含义：有符号数加减运算的正负性 SF = 0表示正数\n计算方法：最高位的本位和\n对无符号数的加减无意义\nZF：\n含义：运算结果是否为 0 ZF=1表示运算结果为 0 CF：\n含义：进位/借位标志，是否发生了进位或借位 CF = 1 表示无符号数加减法出现了进位 / 借位 / 溢出\n计算方法最高位产生的进位与sub进行异或 减法sub=1，加法sub=0\n对有符号数的加减法无意义\n定点数加减法 数据的存储和排列 大端方式：从字节最高位到最低位顺序存储\n小端方式：从字节最低位到最高位顺序存储\n按边界对齐和不对齐存储方式\n浮点数 表示格式：\n阶码通常用移码表示 （移码为真值加偏移量）\n全 0 阶码全 0 尾数：符号取决于数符，一般情况下 +0 和 -0 时等效的\n全 1 阶码全 0 尾数： 表示正负无穷，正无穷大于所有有限数，负无穷小于所有有限数\n真值计算：$(-1)× 数符 × 基数^{阶码} × 尾数$ 基数为隐含的，题中一般会给出，默认为 2\n浮点数规格化： 左归：尾数左移 n 位，阶码减 n\n右归：尾数右移 n 位，阶码加 n\n在 IEEE754 中尾数最高位隐含一位 1 ，计算时要留意\nIEEE754浮点数格式 浮点数加减运算 小阶向大阶看起，尾数加减，计算完之后进行规格化，只有规格化之后溢出才是真溢出\n第三章—存储系统 存储容量：存储字数 × 字长 存储字数表示存储器地址空间大小，字长表示依次存取操作的数据量\n存储速度：数据传输速率 = 数据带宽 / 存储周期\n存取时间：从启动到完成操作的时间，分为读入时间和写入时间\n存取周期：进行一次完整的读写操作需要的全部时间 包含最后的恢复时间\n主存带宽：又称数据传输速率，表示每秒从主存进出信息的最大数量，单位为 字/秒、字节/秒(B/s)、位/秒(b/s)\n主存储器（RAM） SRAM：静态随机存储器，使用双稳态触发器，非破坏性读出，存储速度快，集成度低，功耗大，价格昂贵，一般用于高速缓冲器\nDRAM：动态随机存储器，使用栅极电容存储器，破坏性读出，容易集成，价格低，容量大，功耗低，比 SRAM 慢，隔一段时间需要刷新，通常取 2ms\nDRAM 刷新方式\n集中刷新：利用一段固定的时间进行刷新，优点：读写时不受影响。缺点：存在死区\n异步刷新：2ms内每行都刷新一次，2ms / 行数 = n ms，每 n ms刷新一行\nDRAM刷新对CPU时透明的，刷新单位为行，芯片内部自行生成地址\n分散刷新：每次读写完就刷新一行，优点：没有死区。缺点：增加了存储周期 SRAM和DRAM的对比 只读存储器（ROM） 结构简单，位密度高\n具有非易失性，可靠性高\n多模块存储器 单体多字存储器 存储器中只有一个存储体，每个存储单元存储 m 个字，总线宽度也为 m 个字，一行并行读出 m 个字，地址必须顺序排列并处于同一存储单元。\n多体并行存储器 有多体模块组成，每个模块有相同的容量和存储速度，各模块都有相同的读写控制电路、地址寄存器和数据寄存器。他们既能并行工作，又能交叉工作\n多体并行存储器有高位交叉编址和低位交叉编址\n高位交叉编址\n顺序存储方式，高位地址表示体号，低位地址表示为体内地址\n低位交叉编址\n低位地址为体号，高位地址为体内地址，用模运算来获得体号，\n设模块字长等于数据总线宽度，模块存取一个字的存取周期为 T ，总线传送周期为 r ，实现流水线方式存取，存储器交叉模块数应大于等于$m=T{\\div} r$，连续存取 m 个字需要时间为 $t=T+(m-1)\\times r$\n主存容量的扩展 位扩展 扩展的是数据总线\n字扩展 扩展的是地址总线\n字位同时扩展 存储芯片的地址分配和片选 线选法：某地址线信息为 0 ，就是选中与之对应的存储芯片。优点：不需要译码器，线路简单。缺点：地址空间不连续，\n译码片选法：通过地址译码器产生片选信号\n外部存储器 磁盘存储器\n扇区是磁盘读写的最小单位\n平均存取时间：由寻道时间，旋转延时，传输时间\n数据传输率： r 转/秒，磁道容量 N 字节，D = r × N\n磁盘地址结构\n高速缓冲存储器（Cache） 通常由 SRAM 组成，为了方便 Cache 与主存交换信息，Cache 和主存都被划分为相等的块，Cache 块又称为 Cache 行，每行由一些字组成，块的长度称为块长\nCPU 和 Cache 之间的数据交换以字为单位\n时间局部性：最近的未来要使用的信息可能为现在正在使用的信息\n空间局部性：最近的未来要使用的信息可能与现在正在使用的信息在存储空间上是临近的\n命中率(CPU -\u0026gt; Cache)：总命中次数为 N，访问主存的总次数为 M ，则命中率为：$H=\\frac{N}{N+M} $ 命中率越接近 1 越好\n平均访问时间(Cache和主存)：K 为命中 Cache 的访问时间，L为未命中访问时间，1 - H 表示未命中率，平均访问时间：$T=h\\times K+(1- H)\\times L$\nCache和主存的映射方式 全相联映射：\n主存块可以放在 Cache 的任意位置\n优点：空间利用充分，命中率高；缺点：查找速度慢，需要对比所有标记的行\n直接映射：\n每个主存块只能放到一个特定的位置：\nCache 块号 = 主存块号 % Cache总块数\n优点：标记对比速度快；缺点：空间利用不充分，命中率低\n组相联映射：\nCache 块分为若干组，每个主存块可放到特定分组中的任意一个位置\n组号 = 主存块号 % 分组数\n优点：另外两种方式的折中，综合效果好\nCache替换算法 在操作系统中学习\n随机算法（RAND）\n先进先出（FIFO）\n近期最少使用（LRU）\nCache写策略 写命中的两种处理方法 全写法：\nCPU 对 Cache 写命中时，必须把数据同时写入 Cache 和主存，当某一块要替换时，直接覆盖即可，\n优点：能随时保持主存数据的正确性 缺点：增加了访问次数，降低了 Cache 的效率 解决方法：通过在CPU和主存之间添加一个写缓冲，可以保证对Cache和主存的写入速度一致\n回写法：\n当 CPU 对 Cache 写命中时，只把数据写入 Cache ，当这个块被替换时，才将数据写入主存\n优点：减少了访存次数 缺点：存在数据不一致的隐患 解决方法：对每个 Cache 行设置一个修改位，1 表示被修改过\n写不命中的两种处理方法 写分配\n加载主存块到 Cache 中，然后更新这个块，利用了空间局部性原理；缺点：每次不命中都要从主存中读取一块\n非写分配\n只写入主存，不进行调块\n非写分配法通常和全写法合用，写分配法通常和回写法合用\n虚拟存储器 页式存储器 以页为基本单位，虚拟空间与主存空间都被划分为同样大小的页，主存的页称为实页，页框，虚存的页称为虚页\n虚拟地址分为两个字段：虚页号和页内地址\n优点：页面长度固定，页表简单，调入方便 缺点：程序不可能正好是页面的整数倍，最后一页的留头无法利用而造成浪费\n页表\n包含的字段：\n有效位：1表示虚拟页已从外存调入内存，页表项存放该页的物理页号，0表示没有调入主存，页表项可以存放该页的磁盘地址\n脏位：修改位，表示页面是否被修改过，采用回写法策略\n引用位：使用位，配合替换策略进行使用\n快表（TLB）\n采用全相联或组相联映射，快表与页表的关系就像是内存和 Cache 的关系\n地址变换过程\n先将地址虚拟地址转换为主存物理地址，页表地址寄存器存放进程的页表首地址，然后根据虚拟地址的虚拟页号找到对应的页表项，若装入位为 1，则取出物理页号，和虚拟地址的页内地址拼接，形成实际物理地址\n段式虚拟存储器 段是按照程序的逻辑结构划分，每个段的长度因程序而异，虚拟地址分为两个部分，段号和段内地址，虚拟地址到实际地址的变换由段表来实现。段表是程序逻辑段和在主存中存放位置的对照表。段表记录包括段号、装入位、段起点、段长等信息。已调入主存时，从段表读出在主存的起始地址，与段内地址（偏移量）相加得到对应的主存实地址。\n优点：段的分界与程序的自然分界相对应，具有逻辑独立性，易于编译、管理、修改和保护 缺点：段的长度可变，不好分匹配空间，容易留下碎片\n虚拟存储器和 Cache 的比较\n1.相同之处\n最终目标都是为了提高系统性能，两者都有容量、速度、价格的梯度\n都把数据划分为小信息块，并作为基本的传递单位，虚存系统的信息块更大\n都有地址的映射、替换算法、更新策略等问题\n依据程序的局部性原理应用“快速缓存的思想”，将活跃的数据放在相对高速的部件中\n2.不同之处\nCache主要解决系统速度，而虚拟存储器却是为了解决主存容量\nCache全由硬件实现，是硬件存储器，对所有程序员透明；而虚拟存储器由OS和硬件共同实现，是逻辑上的存储器，对系统程序员不透明，但对应用程序员透明\n对于不命中性能影响，虚拟存储器系统不命中时对系统性能影响更大\nCPU与Cache和主存都建立了直接访问的通路，而辅存与CPU没有直接通路。也就是说在Cache不命中时主存能和CPU直接通信，同时将数据调入Cache；而虚拟存储器系统不命中时，只能先由硬盘调入主存，而不能直接和CPU通信。\n存储周期和存取时间有什么区别？\n存取时间仅为完成一次操作的时间，存取周期不仅包含操作时间，而且包含操作后线路的恢复时间 存储周期 = 存取时间 + 恢复时间\n存储周期就是存取周期 ？\n不是 存取时间是执行一次都读操作或写操作的时间，分为读出时间和写入时间 存储周期包含存取时间和恢复时间，是指存储器进行连续两次独立的读或写操作所需的最小时间间隔 一般储存周期大于存取时间\n第四章—指令系统 指令格式 指令有操作码字段和地址码字段组成\n操作码：指出执行什么性质的操作以及具有什么功能 地址码：给出被操作数据的地址，\n指令长度是指一条指令中所包含的二进制代码的位数，指令字长取决于操作码的长度、操作数地址码的长度和操作数地址的个数\n定长操作码指令：对于简化计算机硬件设计，提高指令译码和识别速度有利\n扩展操作码指令：采取可变长的操作码，操作码位数随地址码位数的减少而增加\n转移指令：\n无条件转移 条件转移 调用 返回 陷阱 JMP BRANCH CALL RET TRAP 设地址长度为 n ，上一层留出 m 种状态，下一层可扩展出$m\\times2^{n}$种状态\n寻址方式 分为指令寻址和数据寻址\n指令寻址 定义：寻找下一条将要执行的指令；指令寻址有顺序寻址和跳跃寻址，顺序寻址：通过程序计数器 PC 加一（ 1 个指令字长），自动形成下一条指令的地址；跳跃寻址：通过转移类指令实现，跳跃是指下条指令的地址不由程序计数器 PC 自动给出，由本条指令给出下条指令地址的计算方式。而是否跳跃可能受状态寄存器和操作数的控制，跳跃的地址分为绝对地址和相对地址，跳跃的结果是当前指令修改 PC 值，所以下一条指令仍是通过 PC 给出。\n数据寻址 定义：寻找本条指令的数据地址称为数据寻址。数据寻址的方式比较多，为区别各种格式，通常在指令字中设一个字段，用来指明属于那种寻址方式。指令的格式如下\n常见的数据寻址方式 隐含寻址： 在指令中隐含操作数的地址，例如单地址指令的格式，仅指出第一操作数的地址，规定累加器（ACC）为第二地址 优点：利于缩短指令字长；缺点：增加存储操作数或隐含地址的硬件\n立即（数）寻址： 指出的是操作数本身，用补码表示 优点：执行阶段不访问主存，指令执行时间最短；缺点：操作数的位数限制了立即数的范围\n直接寻址： 指令中的形式地址是操作数的真实地址 优点：简单，指令在执行阶段进访问一次主存，不需要计算操作数的地址；缺点：操作数的位数决定了该指令操作数的寻址范围，操作数的地址不易修改\n间接寻址： 给出的不是操作数的真正地址，而是操作数地址的地址，间接寻址可以是一次间接寻址，还可以是多次间接寻址 优点：可扩大寻址范围；缺点：执行阶段要多次访存，一次间接寻址要两次访存\n寄存器寻址： 在指令字中直接给出操作数所在寄存器的寄存器编号 优点：执行阶段不访问主存，只访问寄存器，执行速度快，支持向量/矩阵运算；缺点：寄存器价格昂贵，计算机中的寄存器个数有限\n寄存器间接寻址： 在寄存器中给出的不是一个操作数，而是操作数所在主存单元的地址 优点：比一般间接寻址速度快；缺点：执行阶段需要访问主存\n相对寻址： 用 PC 的内容加上指令格式中的形式地址，得到操作数的有效地址，形式地址可以为正或负，用补码表示 以 PC 当前指定的位置作为起点 优点：操作数的地址不是固定的，与指令地址总是相差一个固定的值，便于程序浮动，广泛用于转移指令。 如果执行的是转移指令(假如占 2B)，取出指令后 PC 中的值会增加 2，执行完该指令后会再增加一个指令的长度\n基址寻址： 将 CPU 中的基址寄存器( BR )的内容加上指令格式中的形式地址形成操作数的有效地址 以程序的起始地址作为起点 优点：可扩大寻址范围，利于多道程序设计；缺点：偏移量（形式地址）的位数短 基址寄存器是面向操作系统的，内容由操作系统或管理程序确定，在程序执行期间内容不可变\n变址寻址：\n将指令字中的形式地址加上变址寄存器的内容形成有效地址 由程序员指定从哪里开始 优点：可扩大寻址范围，足以表示整个存储空间 变址寄存器是面向用户的，在程序执行过程中，其内容可以被用户改变\n堆栈寻址： 堆栈是存储器中一块特定的、按先进先出原则管理的存储区，存储区中读写单元的地址用堆栈指针给出\n指令寻址方式的特点和适用情况\n立即寻址操作数获取便捷，通常用于给寄存器赋初值。\n直接寻址相对于立即寻址，缩短了指令长度。\n间接寻址扩大了寻址范围，便于编制程序，易于完成子程序返回。\n寄存器寻址的指令字较短，指令执行速度较快。\n寄存器间接寻址扩大了寻址范围。\n基址寻址扩大了操作数寻址范围，适用于多道程序设计，常用于为程序或数据分配存储空间。\n变址寻址主要用于处理数组问题，适合编制循环程序。\n相对寻址用于控制程序的执行顺序、转移等。\n基址寻址和变址寻址的区别:两种方式有效地址的形成都是寄存器内容+偏移地址，但是在基址寻址中，程序员操作的是偏移地址，基址寄存器的内容由操作系统控制，在执行过程中是动态调整的;而在变址寻址中，程序员操作的是变址寄存器，偏移地址是固定不变的。\n机器级代码表示 参数说明\n中括号 \u0026quot; [ ] \u0026quot; 表示地址，地址后面可以加减偏移量\ndword：双字；word：单字；byte：字节；\n数据传送指令\nmov \u0026lt;\u0026gt;,\u0026lt;\u0026gt;; 将第二个操作数复制到第一个操作数\npush \u0026lt;\u0026gt;; 将操作数压入内存的栈，通常用于函数调用，ESP 是栈顶，压栈前先将 ESP 减 4\npop \u0026lt;\u0026gt;; 出栈操作，出栈前先将 ESP 指向的内容出栈，再将 ESP 的值加 4\n算数和逻辑运算指令\nadd/sub \u0026lt;\u0026gt;,\u0026lt;\u0026gt;; 将两个操作数相加，结果保存到第一个操作数中，sub 为相减\ninc/dec \u0026lt;\u0026gt;; 将操作数自加\nimul \u0026lt;\u0026gt;,\u0026lt;\u0026gt;,\u0026lt;\u0026gt;; 乘法指令,第一个必须为寄存器，操作数可以为三个或两个\nidiv \u0026lt;\u0026gt;; 带符号整数除法，只有一个操作数，被除数为隐含的\nand/or/xor \u0026lt;\u0026gt;,\u0026lt;\u0026gt;; 逻辑与、或、非，结果放在第一个操作数中\nnot \u0026lt;\u0026gt;; 取反，将操作数中的每一位取反\nneg \u0026lt;\u0026gt;; 取负数\nshl/shr \u0026lt;\u0026gt;,\u0026lt;\u0026gt;; 逻辑位移，shl 为左移，shr 为右移\n流程控制指令\nx86 处理器维持着一个指示当前执行指令的指令指针 IP ，当一条指令执行后自动指向下一条指令\n通过给某条语句前加一个标记，再通过跳转指令跳转到这个位置\njmp ; 转移指令，控制 IP 跳转到指定的 lable 标记\nj condition \u0026lt;\u0026gt;; 条件转移指令，condition为可选参数 je \u0026lt;\u0026gt;; 相等时跳转 jne \u0026lt;\u0026gt;; 不相等时跳转 jz \u0026lt;\u0026gt;; 左后结果为 0 跳转 jg \u0026lt;\u0026gt;; 大于时跳转 jge \u0026lt;\u0026gt;; 大于或相等时跳转 jl \u0026lt;\u0026gt;; 小于时跳转 jle \u0026lt;\u0026gt;; 小于或等于时跳转\ncmp/test \u0026lt;\u0026gt;,\u0026lt;\u0026gt;; 比较两个操作数的值，test进行逐位与运算，不保存操作结果，仅根据运算结果设置 CPU 状态字中的条件码\ncall/ret \u0026lt;\u0026gt;; 实现子程序的调用和返回\nCISC(复杂指令系统)和(精简指令系统)RISC CISC的主要特点 指令系统复杂庞大，指令数目- .般为200条以上。\n指令的长度不固定，指令格式多，寻址方式多。\n可以访存的指令不受限制。\n各种指令使用频度相差很大。\n各种指令执行时间相差很大，大多数指令需多个时钟周期才能完成。\n控制器大多数采用微程序控制。有些指令非常复杂，以至于无法采用硬连线控制。\n难以用优化编译生成高效的目标代码程序。\nCISC的主要特点 选取使用频率最高的一些简单指令，复杂指令的功能由简单指令的组合来实现。\n指令长度固定，指令格式种类少，寻址方式种类少。\n只有Load/Store (取数/存数)指令访存，其余指令的操作都在寄存器之间进行。\nCPU中通用寄存器的数量相当多。\nRISC一定采用指令流水线技术，大部分指令在一个时钟周期内完成。\n以硬布线控制为主，不用或少用微程序控制。\n特别重视编译优化工作，以减少程序执行时间。\nCISC和RISC的对比 CISC RISC 指令系统 复杂，庞大 简单，精简 指令数目 一般大于 200 条 一般小于 100 条 指令字长 不固定 定长 可访存指令 不加限制 只有 Load / Store 指令 各种指令执行时间 相差较大 绝大多数在一个周期内完成 各种指令使用频度 相差很大 都比较常用 通用寄存器数量 较少 多 目标代码 难以用优化编译生成高效的目标代码程序 采用优化的编译程序，生成代码较为高级 控制方式 绝大多数以微程序控制 绝大多数为组合逻辑控制 指令流水线 可以通过一定方式实现 必须实现 ","permalink":"http://localhost:1313/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/","summary":"\u003ch1 id=\"第一章计算机系统概述\"\u003e第一章—计算机系统概述\u003c/h1\u003e\n\u003cp\u003e\u003cstrong\u003eMAR\u003c/strong\u003e 地址寄存器：用于寻址，位数对应存储单元的个数\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eMDR\u003c/strong\u003e 数据寄存器：位数和存储字长相等\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e存储体\u003c/strong\u003e由许多存储单元组成，每个\u003cstrong\u003e存储单元\u003c/strong\u003e包含若干\u003cstrong\u003e存储元件\u003c/strong\u003e，每个存储元件存储一位二进制代码。存储单元可存储一串二进制代码称这串代码为\u003cstrong\u003e存储字\u003c/strong\u003e，称这串代码的位数为\u003cstrong\u003e存储字长\u003c/strong\u003e。\u003c/p\u003e","title":"计算机组成原理"},{"content":"第一章 基本概念 特权指令：I/O 指令、置中断、存取用于内存保护的寄存器，送程序状态字到程序状态寄存器\n非特权指令：允许用户直接使用的指令，不能直接访问程序中的软硬件资源，仅限于访问用户的地址空间\n特权指令运行在核心态，非特权指令运行在核心态\n中断和异常：\n中断：也称为外中断，只来自 CPU 执行指令的外部事件，通常用于信息输入/输出，如 I/O 结束中断，时钟中断 中断可以分为可屏蔽中断和不可屏蔽中断，可屏蔽中断可以实现多重中断，从而使中断处理更加灵活，不可屏蔽中断，通常是紧急的硬件故障，如电源掉电，\n异常：也称为内中断，是指来自内 CPU 执行指令内部的事件，如程序的非法操作码、地址越界、运算溢出、虚存系统的却也及专门的陷入指令等引起的事件，异常不能被屏蔽，发生之后必须立即处理，异常分为故障、自陷、终止。故障通常由指令执行引起的异常，如非法操作码、缺页故障、除数为 0 ，运算溢出等。自陷时一种事先安排的异常事件，用于在用户态下调用操作系统内核程序，如条件陷阱指令。终止时出现了使 CPU 无法继续执行的硬件故障，如控制器出错、存储器校验错等。故障异常和自陷异常输入软件中断，终止异常和外部中断属于硬件中断，\n系统调用：是指用户在程序中调用操作系统所提供的一些子功能，系统调用可以视为特殊的公共子程序\n由用户态转向核心态的例子\n用户程序发生系统调用\n发生一次中断\n用户程序中产生了一个错误状态\n用户程序中企图执行一个特权指令\n从核心态转向用户态由一条指令实现，这条指令也是特权指令，一般是中断返回指令\n从用户态转向核心态用到的访管指令为非特权指令\n操作系统的结构 分层法：\n最底层为硬件，最高层为用户接口，每层只能调用相邻层 优点：便于系统调试和验证，简化了系统的设计和实现，易扩充和易维护 缺点：合理定义各层功能困难，效率差\n模块化：\n按功能将操作系统划分为具有一定独立性的模块 优点：提高操作系统设计的正确性、可理解性和可维护性。增加了操作系统的可适应性。加快了开发过程 缺点：接口规定很难满足对接口的实际需求，无法找到一个可靠的决定顺序\n宏内核\n也称为单内核或大内核，是将系统的主要功能模块都作为一个紧密联系的整体\n微内核\n将内核中最基本的功能保留在内核，将那些不需要在核心态执行的功能移到用户态 基本功能：进程(线程)管理、低级存储器管理、中断和陷入处理 特点：易扩展和灵活、安全可靠、可移植、分布式计算、基于客户/服务器模式\n操作系统引导：\n激活CPU，启动BIOS开始硬件自检、硬件错误会发出蜂鸣、加载带有操作系统的硬盘、加载主引导记录MBR、扫描硬件分区表、加载分区引导记录PBR、加载启动管理器、加载操作系统、\n第二章—进程与线程 为什么引入进程？\n更好的描述和控制程序的并发执行，实现操作系统的并发性和共享性\n​ 当操作系统欲调度某进程运行时，要从该进程的 PCB 中查出其现行状态及优先级；在调度到某进程后，要根据其PCB中所保存的处理机状态信息，设置该进程恢复运行的现场，并根据其PCB中的程序和数据的内存始址，找到其程序和数据；进程在运行过程中，当需要和与之合作的进程实现同步、通信或访问文件时，也需要访问PCB；当进程由于某种原因而暂停运行时，又需将其断点的处理机环境保存在PCB中。\n进程\n是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位 进程是程序的一次执行过程，是一个程序及数据在处理机上顺序执行是所发生的活动，是具有独立功能的程序在一个数据集合上运行的过程\n**进程实体(又称为进程影像)**由程序段、相关数据和 PCB(进程控制块) 组成，所谓创建进程，实质上是创建进程中的 PCB；而撤销进程是撤销进程的 PCB ，进程映像是静态的，进程是动态的。PCB 是进程存在的唯一标识\n进程的特征：动态性(基本特征)、并发性(重要特征)、独立性、异步性\n进程的状态与转换 运行态：正在处理机上运行\n就绪态：已经获得执行需要的一切资源，就差处理机\n阻塞态：正在等待某事件而暂停运行\n创建态：正在被创建\n结束态：正在系统中消失\n进程组织方式：在一个系统中，同行存在着许多进程的 PCB (进程控制块)，他们会处于各种状态，方便进程的调度和管理，将 PCB 按照适当的方法组织起来，常用的组织方式有链接方式和索引方式，链接方式指将同一状态的 PCB 连接成一个队列，索引方式指将同一状态的 PCB 组织在一个索引表中\n进程的阻塞和唤醒 当进程期待的事件未发生时进程便调用阻塞原语 Block ，阻塞是进程的主动行为，\n当阻塞的进程期待的事件发生时进程便调用唤醒原语 Wakeup，将进程从等待队列中移除，放入就绪队列\nBlock 和 Wakeup 必须成对使用\n进程通讯 共享存储 通过对共享空间进行读/写操作实现进程之间的信息交换。对共享空间进行读写操作时，需要借助同步互斥工具\n共享存储又分为两种：低级方式的共享是基于数据结构的共享;高级方式的共享则是基于存储区的共享。操作系统只负责为通信进程提供可共享使用的存储空间和同步互斥工具，而数据交换则由用户自己安排读/写指令完成。\n注意： 进程空间一般都是独立的，进程运行期间一般不能访问其他进程的空间，想让两个进程共享空间，必须通过特殊的系统调用实现，而进程内的线程是自然共享进程空间的。\n消息传递 数据交换以格式化的消息为单位，进程通过系统提供的发送消息和接收消息两个原语进行数据交换\n消息传递有两种方式，直接通信发送进程直接放消息发送给接收进程，并将他挂在接收进程的消息缓冲队列上，接收进程从消息缓冲队列中获取消息，间接通信发送进程把消息发送到某个中间实体，接受进程从中间实体取得消息\n管道通信 是消息传递的一种特殊方式，“管道” 就是链接一个读进程和一个写进程实现他们之间通讯的一个共享文件——pipe文件 写进程以字符流的形式往管道文件中写入数据，读进程以字符流形式从管道文件读出数据，由此完成管道通讯 管道机制必须提供以下三方面的协调能力：互斥、同步、确定对方存在\n数据在管道中遵守先进先出原则，管道只能采用半双工通信，父子进程实现通信，需要定义两个管道\n线程和多线程模型 引入线程的目的是减少程序在并发执行时所付出的时空开销，提高操作系统的并发性能，进程提高了资源利用率和系统吞吐量\n线程基本感念： 线程最直接的理解就是“轻量级进程”，它是一个基本的CPU执行单元，也是程序执行流的最小单元，由线程ID、程序计数器、寄存器集合和堆栈组成。线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源，但它可与同属一个进程的其他线程共享进程所拥有的全部资源。一个线程可以创建和撤销另一个线程，同一进程中的多个线程之间可以并发执行。由于线程之间的相互制约，致使线程在运行中呈现出间断性。线程也有就绪、阻塞和运行三种基本状态。\n引入线程后，进程只作为除CPU外的系统资源的分配单元，而线程则最为处理机的分配单元\n线程和进程的比较 调度：同一进程中线程切换不会引起进程切换，不同进程中线程切换会引起进程切换\n并发：不同进程的线程可以并发，同一进程的线程也可以并发\n拥有资源：进程是系统中拥有资源的基本单位，进程不拥有系统资源，但是可以访问所属进程的系统资源\n独立性：进程有用独立的地址空间和资源，除了共享全局变量，某进程中的线程对其他进程是不可见的\n系统开销，创建和撤销进程时，需要为之分配或收回进程控制块和其他资源，进程切换设计进程上下文切换，而线程切换只需要保存和设置少量寄存器内容，同一进程下的线程进行通信无需操作系统干预\n支持多处理机系统，可以将进程中的多个线程分配到多个处理机上执行\n线程的实现方式 有两种实现方式：用户级线程和内核级线程\n用户级线程 由应用程序在用户空间内完成，\n优点：进程切换不需要转换到内核态。调度算法可以是进程专用的。线程的实现与操作系统平台无关，对线程管理的代码属于用户程序的一部分\n缺点：系统调用的阻塞问题，当线程执行一个系统调用时，不仅该线程被阻塞，而且进程内的所有线程都被阻塞。不能发挥多处理机的优势，内核每次分配给一个进程的仅有一个CPU，因此进程中仅有一个线程能执行。\n内核级线程 在内核的支持下运行，线程管理的工作都在内核空间内实现\n优点：能发挥多处理机的优势，内核能同时调度同一进程中的多个线程并行执行。如果进程中的一个线程被阻塞，内核可以调度该进程中的其他线程占用处理机，也可运行其他进程中的线程。内核支持线程具有很小的数据结构和堆栈，线程切换比较快、开销小。内核本身也可采用多线程技术，可以提高系统的执行速度和效率。\n缺点：同一进程中的线程切换，需要从用户态转到核心态进行，系统开销大，这是因为用户进程的线程在用户态运行，而线程调度和管理是在内核实现的。\n多线程模型 多对一模型：将多个用户级线程映射到一个内核级线程。优点：线程管理是在用户空间进行的，效率高。缺点：如果一个线程在访问内核时发生阻塞，则整个进程都会被阻塞\n一对一模型：将每个用户级线程映射到一个内核级线程上，优点：并发能力强。缺点：开销大\n多对多模型：将多个用户级线程映射到少量的内核级线程上，内核线程数量不能大于用户线程数量。克服了上面两种缺点，融合了上面两种的优点\n处理机调度 高级调度(作业调度)\n从外存上处于后背队列的作业中选取一个或多个，给他们分配内存、输入输出设备等必要的资源并建立相应的进程。内存与辅存之间的调度，对于每个作业只调入一次、调出一次\n中级调度(内存调度)\n存储器管理中的对换功能\n低级调度(进程调度)\n从就绪队列中选取一个进程分配处理器\n调度程序(调度器)：通常由三部分组成：排队器、分派器、上下文切换器\n调度的时机、切换与过程\n在处理中断、进程在操作系统内核临界区中、其他需要完全屏蔽中断的原子操作过程中不能进行进程的调度与切换\n应该进行调度和切换的情况\n发生引起调度条件且当前进程无法继续进行下去时，非剥夺调度\n中断处理结束或自陷处理结束后，返回被中断进程的用户态程序执行现场前，若置上请求调度标志，即可马上进行程序调度与切换，剥夺方式调度\n闲逛程序 如果系统中没有就绪进程，就会调度闲逛进程（idle）运行，如果没有其他进程就绪，该进程会一直运行，并在执行过程中测试中断，该程序优先级最低，闲逛进程不需要CPU之外的资源，不会被阻塞\n线程调度 调度算法 先来先服务（FCFS）：从就绪队列中选择最先进入该队列的进程，直到运行完成或阻塞才会切换下一个进程，非抢占式调度\n特点：算法简单，效率高；对长作业有利，对短作业不利；有利于CPU繁忙型作业，不利于 I/O 繁忙型作业\n短作业优先（SJF）：从就绪队列中选择估计运行事件最短的进程，直到运行完成或阻塞才会切换下一个进程，非抢占式调度\n进程优先级 进程优先级设置参照原则\n1. 系统进程 ＞ 用户进程\r2. 交互性进程 ＞ 非交互进程\r3. I/O型进程 ＞ 计算型进程\r根据进程创建后其优先级是否可以改变，可以将进程优先级分为 静态优先级：在创建进程时确定，在进程的整个运行期间保持不变 动态优先级：根据进程情况的变化动态调整优先级\n饥饿现象：高优先级需求的持续涌入耗尽了OS中的资源，导致低优先级进程无法获得处理器或资源\n特点：对长作业不利，未考虑作业的紧迫程度，作业的长度使根据用户所提供的估计执行时间而定的；平均等待时间、平均周转时间最少\n先来先服务（FCFS）：从就绪队列中选择最先进入该队列的进程，直到运行完成或阻塞才会切换下一个进程，非抢占式调度\n特点：算法简单，效率高；对长作业有利，对短作业不利；有利于CPU繁忙型作业，不利于 I/O 繁忙型作业\n短作业优先（SJF）：从就绪队列中选择估计运行事件最短的进程，直到运行完成或阻塞才会切换下一个进程，非抢占式调度\n特点：对长作业不利，未考虑作业的紧迫程度，作业的长度使根据用户所提供的估计执行时间而定的；平均等待时间、平均周转时间最少\n优先级调度：从就绪队列中选择优先级最高的，按能否抢占正在执行的进程，可以分为非抢占式和抢占式，主要区别为在进程运行时，更高级别的进程进入就绪队列，是否可以立刻分配到处理器\n高相应比优先调度：进行作业调度时，先计算后备作业队列中每个作业的相应比，从中选出相应比最高的作业投入运行，该算法可以克服饥饿现象 相应比 = ( 等待时间 + 要求服务时间 ) / 要求服务时间\n时间片轮转调度：适用于分时系统，在 FCFS 的基础上为每个作业分配时间片，时间片结束强行切换下一个进程，时间片的长短又系统的响应时间、就绪队列中的进程数目和系统的处理能力\n多级队列调度算法：设置多个就绪队列，将不同类型的进程分配到不同的就绪队列，每个队列实施不同的调度算法\n多级反馈队列调度算法：融合了时间片轮转调度和优先级调度 实现思想： 1、创建多个就绪队列，一级队列优先级最高，依次递减 2、优先级越高的队列中，每个进程的时间片就越小 3、每个队列都采用 FCFS 算法，如果一个进程在一个时间片结束时未完成，就将其转到下一级队列的末尾，新加入的进程在一级队列 4、当第一级队列为空时，才调度二级队列中的进程运行\n进程切换 上下文切换过程：\n上下文切换是在内核的支持下完成的\n挂起进程，保存 CPU 上下文，和程序计数器、相关寄存器\n更新 PCB 信息\n将 PCB 移入相应的队列\n选择新的进程，并更新该进程的 PCB\n跳转到 PCB 中程序计数器所指向的位置\n恢复处理器上下文\n模式切换：用户态和内核态之间的切换称为模式切换\n同步和互斥 同步机制应遵循的准则：\n空闲让进：临界区空闲，允许一个请求进入\n忙则等待：已经有进程在临界区时，其他请求必须等待\n有限等待：保证等待的请求在有限时间内解决\n让权等待：进程不能立即进入临界区，需立刻释放处理器\n信号量实现前驱关系\n经典同步问题 生产者-消费者问题\n读者-写者问题\n哲学家进餐问题\n吸烟者问题\n死锁 多个进程因竞争资源而造成的一种僵局（互相等待），若无外力左右，这些进程都将无法向前推进\n死锁产生的原因\n系统资源的竞争\n进程推进顺序不当\n死锁产生的必要条件\n互斥条件\n不剥夺条件（只能是主动释放）\n请求并保持条件\n循环等待条件\n死锁预防\n防止死锁的发生只需破坏死锁产生的 4 个必要条件之一即可\n破坏互斥条件：允许系统资源可以共享使用 缺点：可行性低，因为打印机之类的只能互斥使用\n破坏不剥夺条件：一个进程请求新的资源得不到满足时，释放所有已占用的资源 缺点：实现复杂，增加系统开销，降低系统吞吐量\n破坏请求并保持条件：运行前一次申请完所需要的全部资源 缺点：系统资源被严重浪费，会导致“饥饿”现象\n破坏循环等待条件：采用顺序资源分配法，给资源编号，进程必须按编号递增顺序请求资源，同类资源一次申请完 缺点：编号必须相对稳定，给编程带来麻烦\n死锁避免\n在资源动态分配过程中，防止系统进入不安全状态，限制条件较弱，可以获得较好的系统性能\n银行家算法 死锁解除\n资源剥夺：挂起某些死锁进程，并抢占它的资源，但要防止被挂起的进程长时间得不到资源\n撤销进程，强制撤销死锁进程，并剥夺其资源\n进程回退：让一个进程回退到可以避免死锁的地步，回退时自愿释放资源而不是剥夺\n第三章—内存管理 固定分区会产生内部碎片，动态分区会产生外部碎片\n程序的链接与装入 编译：由编译程序将用户源代码编译成若干目标模块。 链接：由链接程序将编译后形成的一组目标模块及它们所需的库函数链接在一起，形成一个完整的装入模块。 装入：由装入程序将装入模块装入内存运行\n程序的链接方式 静态链接（非重点） 在程序运行之前，先将各目标模块及它们所需的库函数链接成一个完整的装配模块，以后不再拆开。\n装入时动态链接 将用户源程序编译后所得到的一组目标模块，在装入内存时，采用边装入边链接的方式。优点是便于修改和更新，便于实现对目标模块的共享。\n运行时动态链接 在程序执行中需要该目标模块时才进行链接。凡在执行过程中未被用到的目标模块，都不会被调入内存和被链接到装入模块上。其优点是能加快程序的装入过程，还可节省大量的内存空间。\n内存的装入方式 绝对装入 按照装入模块中的地址，将程序和数据装入内存。绝对装入方式只适用于单道程序环境。\n可重定位装入 根据内存的当前情况，将装入模块装入内存的适当位置。在装入时对目标程序中指令和数据地址的修改过程称为重定位，又因为地址变换通常是在进程装入时一次完成的，故称为静态重定位。当一个作业装入内存时，必须给它分配要求的全部内存空间，若没有足够的内存，则无法装入。此外，作业一旦进入内存，整个运行期间就不能在内存中移动，也不能再申请内存空间。\n动态运行时装入 也称动态重定位。程序在内存中若发生移动，则需要采用动态的装入方式。装入程序把装入模块装入内存后，并不立即把装入模块中的相对地址转换为绝对地址，而是把这种地址转换推迟到程序真正要执行时才进行。因此，装入内存后的所有地址均为相对地址。这种方式需要一个重定位寄存器的支持\n对于32位系统，逻辑地址空间的范围为 0 ~ $2^{32}-1$\n进程的内存映像 一个进程的内存映像一般有几个要素:\n代码段：即程序的二进制代码，代码段是只读的，可以被多个进程共享。\n数据段：即程序运行时加工处理的对象，包括全局变量和静态变量。\n进程控制块(PCB)：存放在系统区。操作系统通过PCB来控制和管理进程。\n堆：用来存放动态分配的变量。通过调用malloc 函数动态地向高地址分配空间。\n栈：用来实现函数调用。从用户空间的最大地址往低地址方向增长。\n内存保护 常用的两种方法\n在CPU中设置一对上、下限寄存器，判断有无越界\n采用重定位寄存器和界地址寄存器：重定位寄存器含最小的物理地址值，界地址寄存器含逻辑地址的最大值\n连续分配管理方式—动态分区分配 动态分区分配策略 首次适应算法：空闲分区以地址递增顺序链接。分配时找到大小能满足要求的第一个空闲分区分配给作业。缺点低地址部分容易产生很多小的空闲分区\n临近适应算法：有首次适应算法演变而成，不同之处，从上次查找结束的位置开始继续查找。容易导致内存空间的尾部分裂成小碎片\n最佳适应算法：按容量递增顺序链接，找到第一个能满足要求且最小的空闲分区分配给作业。性能很差，产生最多的外部碎片\n最坏适应算法：按容量递减顺序链接，找到第一个能满足要求的最大分区。会很快的导致没有可用的大内存块\n分页存储管理 分页管理不会产生外部碎片，每个进程平均只产生半个块大小的内部碎片（业内碎片）\n基本地址变换 快表地址变换 虚拟内存 时间局部性：某条指令一 旦执行，不久后该指令可能再次执行\n空间局部性：访问了某个存储单元，在不久后，其附近的存储单元也将被访问\n时间局部性通过将近来使用的指令和数据保存到高速缓存中，并使用高速缓存的层次结构实现。空间局部性通常使用较大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现。虚拟内存技术实际上建立了“内存一外存”的两级存储器结构，利用局部性原理实现高速缓存。\n页框分配 内存分配策略 固定分配局部置换：为每个进程分配一定数目的物理块，在进程运行期间都不改变。所谓局部置换，是指如果进程在运行中发生缺页，则只能从分配给该进程在内存的页面中选出一页换出\n可变分配全局置换：先为每个进程分配\u0026ndash;定数目的物理块，在进程运行期间可根据情况适当地增加或减少。所谓全局置换，是指如果进程在运行中发生缺页，系统从空闲物理块队列中取出一块分配给该进程，并将所缺页调入。比固定分配局部置换更灵活，可动态增加进程的物理块，但会盲目地给进程增加物理块\n可变分配局部置换：为每个进程分配一定数目的物理块，发生缺页时，只允许从该进程在内存的页面中选出一页换出，不会影响其他进程的运行。若频繁地发生缺页中断，则系统再为该进程分配若干物理块，直至该进程的缺页率趋于适当程度\n物理块调入算法 平均分配算法：将系统中所有可供分配的物理块平均分配给各个进程。\n按比例分配算法：根据进程的大小按比例分配物理块。\n优先权分配算法：为重要和紧迫的进程分配较多的物理块。\n调入页面过程 当进程所访问的页面不在内存中时(存在位为0)，便向CPU发出缺页中断，中断响应后便转入缺页中断处理程序。该程序通过查找页表得到该页的物理块，此时如果内存未满，则启动磁盘I/O，将所缺页调入内存，并修改页表。如果内存已满，则先按某种置换算法从内存中选出一页准备换出；如果该页未被修改过(修改位为0)，则无须将该页写回磁盘；但是，如果该页已被，修改(修改位为1),则必须将该页写回磁盘，然后将所缺页调入内存，并修改页表中的相应表项，置其存在位为1。调入完成后，进程就可利用修改后的页表形成所要访问数据的内存地址。\n页面置换算法 最佳置换算法（OPT）：淘汰页面是以后永不使用的页面，或是在最长时间内不再被访问的页面\n最近最久未使用置换算法（LRU）：选择最近最长时间未访问过的页面予以淘汰，FIFO算法基于队列实现，\n先进先出页面置换算法（FIFO）：优先淘汰最早进入内存的页面，即淘汰在内存中驻留时间最久的页面，基于队列实现\nCLOCK置换算法：\n至少扫描两轮\n改进型CLOCK置换算法\n用修改位 A 和访问位 M 标记页面，根据一定的优先级来找到可以被替换出页面\n**1类A=0,M=0:**最近未被访问且未被修改，是最佳淘汰页。\n**2类A=0,M=1:**最近未被访问，但已被修改，不是很好的淘汰页。\n**3类A=1,M=0:**最近已被访问，但未被修改，可能再被访问。\n**4类A=1,M=1:**最近已被访问且已被修改，可能再被访问。\n执行过程\n从指针的当前位置开始，扫描循环队列，寻找4=0且M=0的1类页面，将遇到的第一个1类页面作为选中的淘汰页。在第一次扫描期间不改变访问位A。\n若第 1 步失败，则进行第二轮扫描，寻找4=0且M=1的2类页面。将遇到的第一个2类页面作为淘汰页。在第二轮扫描期间，将所有扫描过的页面的访问位都置0。\n若第 2 步也失败，则将指针返回到开始的位置，并将所有帧的访问位复0。重复第 1 步，并且若有必要，重复第2)步，此时一定能找到被淘汰的页。\n抖动和工作集 抖动：刚刚换出的页面马上又要换入主存，刚刚换入的页面马上又要换出主存\n发生抖动的原因：系统中同时运行的进程太多，由此分配给每个进程的物理块太少，不能满足进程正常运行的基本要求，致使每个进程在运行时频繁地出现缺页，必须请求系统将所缺页面调入内存。\n工作集：在某段时间间隔内，进程要访问的页面集合。\n假设系统为该进程设定的工作集窗口大小4为5，则在 t1 时刻，进程的工作集为{2, 3, 5}，在 t2 时刻，进程的工作集为{1,2,3, 4}。\n内存映射文件 内与虚拟内存有些相似,将磁盘文件的全部或部分内容与进程虚拟地址空间的某个区域建立映射关系，便可以直接访问被映射的文件，而不必执行文件I/O操作，也无须对文件内容进行缓存处理。适合用来管理大尺寸文件。\n地址翻译考不考？ 第四章—文件管理 文件控制块\n文件控制块(FCB) 是用来存放控制文件需要的各种信息的数据结构，以实现“按名存取”。FCB的有序集合称为文件目录，一个FCB就是一一个文件目录项。\nFCB主要包含的信息：\n基本信息：如文件名、文件的物理位置、文件的逻辑结构、文件的物理结构等。\n存取控制信息：包括文件主的存取权限、核准用户的存取权限以及一般用户的存取权限。\n使用信息：，如文件建立时间、上次修改时间等。\n一个文件目录也被视为一一个文件，称为目录文件。\nFCB在磁盘中必须连续存放\n文件按的逻辑结构 无结构文件（流式文件） 无结构文件将数据按顺序组织成记录并积累、保存，以字节(Byte) 为单位。对记录的访问只能通过穷举搜索的方式，但是管理简单，用户可以方便地对其进行操作。较适于采用字符流的无结构方式，如源程序文件、目标代码文件等。\n有结构文件（记录式文件） 顺序文件\n文件中的记录顺序排列，记录通常是定长的，可以顺序存储或以链表形式存储。顺序文件两种结构：第一种是串结构，记录之间的顺序与关键字无关，通常是按存入时间的先后进行排列，检索必须从头开始顺序依次查找。第二种是顺序结构，指文件中的所有记录按关键字顺序排列，可采用折半查找法，检索效率高。每次要读或写一大批记录时，顺序文件的效率是所有逻辑文件中最高的。对于顺序存储设备(如磁带)，也只有顺序文件才能被存储并能有效地工作。在经常需要查找、修改、增加或删除单个记录的场合，顺序文件的性能也比较差。\n索引文件\n建立一张索引表，为主文件的每个记录在索引表中分别设置一个表项，包含指向变长记录的指针(即逻辑起始地址)和记录长度，索引表按关键字排序，其本身也是一个定长记录的顺序文件。\n索引顺序文件\n将顺序文件中的所有记录分为若干组，为顺序文件建立一张索引表， 在索引表中为每组中的第一条记录建立一个索引项，其中含有该记录的关键字值和指向该记录的指针。\n文件的物理结构 连续分配 要求每个文件在磁盘上占有一组连续的块，连续分配支持顺序访问和直接访问。\n优点：是实现简单、存取速度快。\n缺点：\n文件长度不宜动态增加\n删除和插入记录时，需要对相邻的记录做物理上的移动，还会:动态改变文件的长度\n反复增删文件后会产生外部碎片\n只适用于长度固定的文件\n链接分配 采用离散分配的方式。它消除了磁盘的外部碎片，可以动态地为文件分配盘块。链接分为显示链接和隐式链接\n隐式链接：目录项中含有文件第一块的指针和最后一块的指针。除最后一个盘块外，每个盘块都含有指向文件下一个盘块的指针，这些指针对用户是透明的。 缺点：只适合顺序访问，随机访问效率很低，软件或硬件错误导致链表中的指针丢失或损坏，解决方案：将几个盘块组成簇，，按簇而不按块来分配，代价是增加了内部碎片\n显示链接：链接文件个物理块的指针，显示地存放在内存的一张链接表中，整个磁盘中只有一张，称为文件分配表（FAT）这个表在系统启动时就会被读入内存，因此查找记录的过程是在内存中进行的\n索引分配 将每个文件所有的盘块号都集中放在一起构成索引块(表)。优点：是支持直接访问，且没有外部碎片问题。缺点是由于索引块的分配，增加了系统存储空间的开销。索引块的大小是一个重要的问题，每个文件必须有一个索引块，因此索引块应尽可能小，但索引块太小就无法支持大文件。\n解决方案：\n链接方案：将多个索引块链接起来。\n多层索引：通过第一级索引块指向一组第二级的索引块，第二级索引块再指向文件块。\n混合索引：将多种索引分配方式相结合的分配方式。\n混合索引 直接地址；一次间接地址；多次间接地址\n目录 一个FCB就是一个文件目录项，目录管理通过属性结构来解决和实现\n目录结构 单级目录结构：\n在整个文件系统中只建立一张目录表，访问文件先找FCB\n实现了“按名存取”，但查找速度慢，不允许重名，不便共享\n两级目录文件;\n将文件目录分成主文件目录，和用户文件目录\n主文件目录项记录用户名及相应用户文件目录所在的存储位置。用户文件目录项记录该用户文件的FCB信息。\n提高了检索速度，解决了多用户之间的文件重名问题，文件系统可以在目录上实现访问限制。但是两级目录结构缺乏灵活性\n树形目录结构：\n从根目录出发的路径称为绝对路径。\n“./s”就是一个相对路径，其中符号“ . ”表示当前工作目录。\n树形目录结构可以很方便地对文件进行分类，层次结构清晰，也能够更有效地进行文件的管理和保护。不便实现用户共享\n在树形目录中查找一个文件，需要按路径名逐级访问中间结点，增加了磁盘访问次数，这无疑会影响查询速度\n无环图目录结构：\n树形目录结构的基础上增加了一些指向同一结点的有向边，使整个目录成为一个有向无环图，\n为每个共享结点设置一个共享计数器，每当图中增加对该结点的共享链时，计数器加1；每当某用户是出删除该结点时，计数器减1。仅当共享计数器为0时，才真正删除该结点，否则仅删除请求用户的共享链。\n实现了文件的共享，但使得系统的管理变得更加复杂。\n文件系统 文件共享 硬链接：\n必须将共享文件或子目录链接到两个或多个用户的目录中\n文件的物理地址及其他的文件属性等信息，不再放在目录项中，而放在索引结点中。在文件目录中只设置文件名及指向相应索引结点的指针。\n软链接：\n通过一个LINK文件进行共享，LINK文件中包含了目标文件的路径等。\n文件系统在磁盘中的结构： 磁盘划分为一个或多个分区，每个分区中有一一个独立的文件系统。\n主引导记录：位于磁盘的0号扇区，用来引导计算机，MBR后面是分区表，该表给出每个分区的起始和结束地址。\n引导块：MBR执行引导块中的程序后，该程序负责启动该分区中的操作系统。为统一起见，每个分区都从一个引导块开始，即使它不含有一个可启动的操作系统\n超级块：包含文件系统的所有关键信息\n文件系统中空闲块的信息，可以使用位示图或指针链接的形式给出。\n文件系统在内存中的结构 内存中的信息用于管理文件系统并通过缓存来提高性能。这些数据在安装文件系统时被加载，在文件系统操作期间被更新，在卸载时被丢弃。\n安装表：包含每个已安装文件系统分区的有关信息\n整个系统的打开文件表：包含每个打开文件的FCB副本及其他信息\n每个进程的打开文件表：包含一个指向整个系统的打开文件表中的适当条目的指针\n为了创建新的文件，文件系统将为文件分配一个新的FCB\n一旦文件被创建，它就能用于I/O。一旦文件被打开，内核就不再使用文件名来访问文件，而使用文件描述符\n外存空闲空间管理 在一个卷中，存放文件数据的空间(文件区)和FCB的空间(目录区)是分离的。卷在提供文件服务前，必须做好初始化，划分好目录区和文件区\n文件存储设备分成许多大小相同的物理块，并以块为单位交换信息\n空闲表法 属于连续分配方式，为每个文件分配一块连续的存储空间\n空闲盘区的分配与内存的动态分配类似，同样采用首次适应算法和最佳适应算法等。系统在对用户所释放的存储空间进行回收时，也采取类似于内存回收的方法\n空闲链表法：\n将所有空闲盘区拉成一条空闲链。\n空闲盘块链：将空闲空间以盘块为单位拉成一条链。 优点是分配和回收一个盘块的过程非常简单，缺点效率较低。又因它是以盘块为单位的，空闲盘块链会很长。\n空闲盘区链：将磁盘上的所有空闲盘区拉成一条链。 每个盘区除含有用于指示下一个空闲盘区的指针外，还应有能指明本盘区大小的信息。盘区分配通常采用首次适应算法。在回收盘区时，同样也要将回收区与相邻接的空闲盘区合并。缺点：分配和回收过程复杂，但是效率高，空闲盘区链较短\n位示图法：磁盘上所有的盘块都有一个二进制位与之对应。当其值为“0” 时，表示对应的盘块空闲;为“1”时，表示已分配。\n","permalink":"http://localhost:1313/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","summary":"\u003ch1 id=\"第一章\"\u003e第一章\u003c/h1\u003e\n\u003ch2 id=\"基本概念\"\u003e基本概念\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e特权指令\u003c/strong\u003e：I/O 指令、置中断、存取用于内存保护的寄存器，送程序状态字到程序状态寄存器\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e非特权指令\u003c/strong\u003e：允许用户直接使用的指令，不能直接访问程序中的软硬件资源，仅限于访问用户的地址空间\u003c/p\u003e","title":"操作系统"},{"content":"顺序表主要特点是随机访问，存储密度高，逻辑相邻的元素物理结构上也相邻，插入删除需要移动大量的元素\n队列 队列的存储结构\n1define MaxSize 2 typedef struct{ 3 Elemtype data[MaxSize]; 4 int front;\t//队头指针：指向队头元素 5 int reat;\t//队尾指针：指向队尾元素的下一个位置 6 }SqQueue 7 循环队列判空和判满：\n​\t顺序存储\n初始状态：front == rear 队首指针进 1 ：front = ( front + 1 ) % MaxSize 队尾指针进 1 ：rear = ( rear + 1 ) % MaxSize 队列长度：（ rear - front + MaxSize ) % MaxSize 判空：front == rear 判满：( rear + 1 ) % MaxSize == front\n​\t链式存储\n判空：front == rear 判满：front == reat -\u0026gt; next\n栈的应用 计算表达式\n表达式求值\n稀疏矩阵 ​\t仅存储非零元素，构成三元组（行标、列标、值）\nKMP算法？ 树与二叉树 ​\t节点数 = 总度数 + 1\n卡特兰数 n 个元素进栈，出栈顺序不同的个数 n 个节点的二叉树有多少种\n$\\frac{1}{n+1} C_{2n}^{n}$\n特殊的二叉树 满二叉树\n只有度为 2 的节点\n对每一个节点编号，双亲节点为 $\\left \\lfloor i{\\div} 2 \\right \\rfloor $\n左孩子为 $2\\times i$ ，右孩子为 $2\\times i+ 1$\n完全二叉树\n只有一个度为 1 的节点\n若 $i\\le \\left \\lfloor i{\\div} 2 \\right \\rfloor$ 则 i 节点为分支节点，否则为叶子节点\n当节点数为奇数时，每个节点都有左右孩子节点\n二叉排序树\n左子树上的所有关键字都小于根节点的关键字\n右子树上的所有关键字都大于根节点的关键字\n平衡二叉树（AVL树）\n左子树和右子树的深度之差小于 1 二叉树的性质\n度为 0 的节点 = 度为 2 的节点 + 1\n非空二叉树上面至多有 $2^{k-1} $ 个结点\n高度为 h 的二叉树至多有 $2^{h}-1 $ 个结点，至少有h个结点\n从上往下，从左往右依次编号，i 节点所在的层次(深度)为 $\\left \\lfloor \\log_{2}{i} \\right \\rfloor + 1$\n具有 n 个结点的完全二叉树的高度为 $\\left \\lceil \\log_{2}{(n+1)} \\right \\rceil $\n二叉树的存储结构\n​\t顺序存储就是将每个分量都存储在数组当中，用 0 来填充没有的节点\n链式存储\n1typedef struct biNode{ 2 ElemType date;\t//数据域 3\tstruct BiTNode *lchild;\t//左孩子 4\tstruct BiTNode *rchild;\t//右孩子 5} 二叉树遍历 先序遍历 1//中左右 2void PreOrder(BiTree T){ 3 if(t != null){ 4 visit(t);\t//访问根节点 5 PreOrder(t-\u0026gt;lchild);\t//遍历左子树 6 PreOrder(t-\u0026gt;rchild);\t//遍历右子树 7 } 8} 中序遍历 1//左中右 2void PreOrder(BiTree T){ 3 if(t != null){ 4 PreOrder(t-\u0026gt;lchild);\t//遍历左子树 5 visit(t);\t//访问根节点 6 PreOrder(t-\u0026gt;rchild);\t//遍历右子树 7 } 8} 后序遍历 1//左右中 2void PreOrder(BiTree T){ 3 if(t != null){ 4 PreOrder(t-\u0026gt;lchild);\t//遍历左子树 5 PreOrder(t-\u0026gt;rchild);\t//遍历右子树 6 visit(t);\t//访问根节点 7 } 8} 由遍历序列构造二叉树 由先序和中序确定 ​\t在先序遍历序列中。第一个节点一定是二叉树的根结点。在中序遍历中根节点必将中序序列分割成两个子序列。前一个子序列是根节点的左子数的中序序列，后一个子序列是根结点的右子数的中序序列。\n由后序和中序确定二叉树。 ​\t后续序列的最后一个节点，可将中序序列分割成两个子序列。\n注：先序和后序不能构成二叉树\n线索二叉树 ​\t建立线索二叉树，或者说对二叉树进行线索化，实质上就是遍历二叉树的过程中，将二叉链表中的空指针改为指向前驱或后继的线索\n树、森林与二叉树之间的转换 树转二叉树 树对应的二叉树没有右子树\n左右相邻的连线\n保留与第一个孩子的连线，删除与其他孩子的连线\n以根节点为轴心，顺时针旋转45°\n森林转二叉树 将树转为二叉树\n第一棵树不动，从第二棵树开始依次把后一棵二叉树的根节点作为前一棵树的右孩子\n二叉树转森林 二叉树转为树或森林是唯一的\n若某节点是某双亲的左孩子，则把该节点的右孩子，右孩子的右孩子……都链接起来\n删除原二叉树中所有的双亲节点与右孩子节点的连线。\n哈夫曼树 最小带权路径长度的二叉树\n构造哈夫曼树 将这N个结点分别作为N棵树仅含一个结点的二叉树，构成森林F。\n从F中选取两棵根结点权值最小的树作为新节点的左、右子树，并且将新节点的权值置为左、右子树上根结点的权值之和。\n从F中删除刚才选出的两棵树，同时将新得到的树加入F中。\n重复步骤2和3，直至F中只剩下一棵树为止。\n并查集 该节点的值为父节点在数组中的位置\n查找 ​\t返回该节点所在单元的根节点 //根节点的值为 -1\n​\t通过 for 循环一直查找父节点，知道 arr[ i ] = -1;\n图 ​\t图不可以是空图\n简单图：不存在重复边，不存在顶点到自身的边\n完全图\n具有 n 个顶点， n ( n - 1) / 2 条边的无向图，称为完全无向图\n具有 n 个顶点， n ( n - 1) 条边的有无向图，称为完全有向图\n一个图有 n 个顶点，如果边小于 n - 1 ，那么这个图必是非连通图\n强连通图最少要 n 条边\n无向图的全部顶点的度的和等于边数的 2 倍\n有向图的全部顶点的入度的和与出度的和相等，并且等于边数\n若一个图有 n 个顶点，并且边大于 n - 1 条，则此图一定有环\n顶点不重复出现的路径称为简单路径，除第一个顶点和最后一个顶点外，其余顶点不重复出现的回路称为简单回路\n一个顶点入度为0、其余顶点入度均为 1 的有向图称为有向树\n图的存储及基本操作 邻接矩阵法 将图中的每个节点编号，并创建一个二维数组，将不同节点的编号当作数组的两个下标，\n邻接矩阵法特点\n无向图的邻接矩阵一定是一个对阵矩阵（并且唯一）\n无向图的第 i 行/列的非零元素的个数正好是顶点 i 的度\n有向图的第 i 行的非零元素的个数正好是顶点 i 的出度\n无向图的第 i 列的非零元素的个数正好是顶点 i 的出度\n稠密图适合用邻接矩阵存储表示\n邻接表法 ​\t在无向图中，选中一个节点作为链表头节点，后面依次跟上该节点所链接的节点\n​\t在有向图中，选中一个节点作为链表头节点，后面依次跟上该节点出度指向的节点\n邻接表法特点\n稀疏图采用邻接表能节省存储空间 十字链表 ​\t是有向图的一种链式存储结构，\n图的遍历 广度优先搜索 (BFS) 类似于二叉树的层次遍历算法，需要借助队列实现\n深度优先搜索 (DFS) 类似于树的线序遍历，是一种递归算法，需要借助栈实现\n​\t邻接矩阵的遍历所得到的 DFS 序列和 BFS 序列是唯一的，邻接表的遍历所得到的 DFS序列和 BFS 序列不是唯一的，所以生成树也不是唯一的\n遍历性能分析\n对于 n 个顶点、e条边的图\n邻接表表示时，DFS的时间复杂度为 O(n + e)，空间复杂度为 O(n)\n邻接表表示时，BFS的时间复杂度为 O(n + e)，空间复杂度为 O(n)\n邻接矩阵表示时，DFS的时间复杂度为$O(n^{2})$，空间复杂度为 O(n)\n邻接矩阵表示时，BFS的时间复杂度为$O(n^{2})$，空间复杂度为 O(n)\n图的应用 最小生成树 一个连通图的生成树包含图的所有顶点，只包含尽可能少的边，若减去一条边就会贬称非连通图，增加一条边必出现回路\n性质\n最小生成树不唯一，当各边的权值不相等时，最小生成树唯一\n最小生成树的边的权值时唯一的\n最小生成树的边数为顶点数减 1\nPrim算法构造最小生成树 ​\t适合用于稠密的图\n​\t从图中选则一个顶点加入树 T，之后选择一个与当前 T 中顶点集合最近的顶点，并将该顶点和对应的边加入 T ，每次操作后 T 中的顶点数和边数都加一，以此类推，直到图中所有顶点都并入了树 T\nKruskal算法 ​\t适用于边稀疏而顶点较多的图，是一种按权值的递增次序选择合适的边构造最小生成树，采用堆来存放边的集合\n​\t不断选取当前未被选取且权值最小的边，若这个边的顶点落在不同的连通分量上，则保留这个边，否则选取下一个\n最短路径 ​\t把带权路径长度最短的那条路径称为最短路径\nFloyd算法求任意两点之间的最短路径\nDijkstra算法 ​\t求一个顶点到其余各顶点的最短路径算法，路径权值不能为负数，基于贪心策略\n​\t使用邻接矩阵 / 邻接表表示时，时间复杂度为$O(n^{2})$\n​\t路径为负数要用 Bellman-Ford算法\n每次从未标记的节点中选择距离出发点最近的节点，标记，收录到最优路径集合中，\n计算刚加入节点 A 的邻近节点 B 的距离（不包含标记的节点）\n若（节点 A 的距离 + 节点 A 到节点 B 的边长）\u0026lt; 节点 B 的距离，就更新节点 B 的距离和前面点\nFloyd算法 ​\t求任意两点之间的最短路径\n​\t时间复杂度为 $O(\\left | n \\right |^{3} )$\n​\t允许路径为负数，但不允许负数路径形成回路\n拓扑排序：由一个无环图的顶点组成的序列\nAOE 网：用边表示活动的网络，\nAOV 网和 AOE 网的区别：都是有向无环图，但是边和顶点所代表的含义时不同的，AOE 网中的边有权值， AOV 网中的边无权值，仅代表顶点之间的前后关系\n关键路径：具有最大路径长度的路径，这条路径上的活动称为关键活动 求关键路径\n快速求关键路径\n事件最早发生时间：从前往后，多路径的最大值\n事件最迟发生时间：从后往前\n活动最早开始时间：指这条弧的起点所表示的事件的最早发生事件\n活动最迟开始时间：指这条弧的终点所表示的事件的最迟发生事件与该活动所需时间之差\n时间余量：为 0 的节点链接起来为关键路径\n关键路径上的所有活动都是关键活动，它是决定整个工程的关键因素。\n对于有几条关键路径的网，只提高一条关键路径上的关键活动速度并不能缩短整个工程的工期，只有加快那些包含在所有关键路径上的关键活动，才能达到缩短工期的目的。\n查找 顺序查找和折半查找 静态查找表：查找指定元素或查找满足某个条件的元素，查找方法有顺序查找，折半查找，散列查找\n动态查找表：需要动态的插入或删除，查找方法有二叉排序树的查找，散列查找\n平均查找长度：平均查找长度时所有查找过程中进行关键字的比较次数的平均值\n当每个元素的查找概率相等，查找成功的平均长度为 $\\frac{n+1}{2} $\n折半查找：又称二分查找，仅适用于有序的顺序存储的顺序表，\n当每个元素的查找概率相等，查找成功的平均长度为 $\\log_{2}{(n+1)}-1 $ 时间复杂度为 $O(\\log_{2}{(n+1)})$\n1public static main(){ 2 int left = 0,right = L.length - 1,mid; 3 4 while(left \u0026lt; hight){ 5 6 mid = (left + right) / 2;\t//设定中间值 7 8 if(L.item[mid] == key)\t//判断是否为查找值，如果是则返回该值 9 return L.item[mid]; 10 else if(L.item[mid] \u0026gt; key) 11 right = mid -1;\t//改变右边界 12 else 13 left = mid +1;\t//改变左边界 14 15 } 16 return -1;\t//查找失败 17} 分块查找：块内元素可以无须，但块之间时有序的，第一个块中的最大关键字小于第二个块中所有的关键字以此类推\n效率分析 长度为 n ，有 b 块，每块有 s 个记录采用顺序查找则平均查找长度为$\\frac{b+1}{2}+\\frac{s+1}{2}=\\frac{s^{2}+2s+n}{2s}$ 采用折半查找则平均查找长度为$\\left \\lceil \\log_{2}{\\left ( b+1\\right ) } \\right \\rceil +\\frac{s+1}{2} $ 若 $s=\\sqrt{n}$ 则平均查找长度取最小值 $\\sqrt{n}+1$\n树形查找 二叉排序树： 左子树节点值 \u0026lt; 根节点 \u0026lt; 右子树\n二叉排序树查找：\n1while(T != null \u0026amp;\u0026amp; T-\u0026gt;date != key){ 2 if(T-\u0026gt;data \u0026gt; key) 3 T = T-\u0026gt;LChild; 4 else 5 T = T-\u0026gt;RChild; 6} 效率分析 平衡二叉树 平均查找长度为$O(\\log_{2}{n})$ 非平衡二叉树平均查找长度为将$(所在层数\\times 该层节点个数)$相加，再除以总节点个数\n二叉排序树删除：\n直接删除这个节点\n右子树空，用左子女填补\n左子树空，用右子女填补\n左右子树都不为空，在右子树上找中序第一个子女填补\n在执行插入和删除操作时，二叉排序树的平均执行时间为$O(\\log_{2}{n})$，二分查找的平均执行时间为$O(n)$\n红黑树 是一个满足如下性质的二叉排序树\n每个节点时黑色或红色\n根节点为黑色\n叶节点（虚构的外部节点、null节点）为黑色\n不存在两个相邻的红节点（即红节点的父节点和孩子节点都是黑色）\n对每个节点，从该节点到任一叶节点的简单路径上，所含黑节点的数量相同\n结论\n从根到叶节点的最长路径不大于最短路径的 2 倍\n有 n 个内部节点的红黑叔的高度 $h\\le 2\\log_{2}{(n+1)} $\n新插入的节点初始为红色\nB树（多路平衡查找树） B树讲解\n一棵m阶B树或为空树，或为满足如下特性的 m 叉树:\n树中每个结点至多有m棵子树(即至多含有 m - 1 个关键字)。\n若根结点不是终端结点，则至少有两棵子树。\n除根结点外的所有非叶结点至少有 $\\left \\lceil m{\\div} 2 \\right \\rceil $ 棵子树(即至少含有 $\\left \\lceil m{\\div} 2 \\right \\rceil - 1$ 个关键字)。\n所有的叶结点都出现在同一层次上，并且不带信息\nB+树 每个分支节点最多有 m 棵子树（孩子节点）\n除根结点外的所有非叶结点至少有 $\\left \\lceil m{\\div} 2 \\right \\rceil $ 棵子树\n结点的子树个数与关键字个数相等\nB 树和 B+ 树的主要差异 同样有 n 个关键字，但是 B 树中的关键字比 B+ 树多 1\nB+ 树中非叶节点的关键字仅起到索引作用，该关键字为子节点中的最大值或最小值\nB+ 树中叶节点包含了全部关键字，B 树中叶节点包含的关键字和其他节点的关键字时不同的\n散列表 散列函数：一个可以把查找表中的关键字映射成该关键字对应的地址的函数\n散列表：根据关键字直接进行访问的数据结构\n理想情况下对散列表查找的时间复杂度为 O(1)\n常用的散列函数：\n直接定址法：$H= a\\times k+ b$\n除留余数法：$H= k % p$\n处理冲突的方法 线性探测法 平方探测法 拉链法 散列表的查找效取决于：散列函数、处理冲突的方法、装填因子\n装填因子：一般为 （表中记录数）/（散列表长度）\n平均查找长度依赖于散列表的装填因子\n装填因子越大，装填的记录越满，发生冲的可能性就越大\n排序 算法稳定性：如果两一些相同的元素 x、y、z 进行排序后顺序保持不变，即还是x、y、z 则这个算法就是稳定的\n内部排序：排序期间将所有元素都放入内存当中的排序\n外部排序：排序期间将所有元素无法全部放入内存当中的排序\n排序算法 排序方法 时间复杂度—最好 时间复杂度—最坏 时间复杂度—平均 空间复杂度 稳定性 插入排序 $O(n)$ $O(n^{2} )$ $O(n^{2} )$ $O(1)$ 稳定 希尔排序 $O(n)$ $O(n^{2} )$ $O(n^{1.3} )$ $O(1)$ 不稳定 冒泡 $O(n)$ $O(n^{2} )$ $O(n^{2} )$ $O(1)$ 稳定 选择排序 $O(n^{2} )$ $O(n^{2} )$ $O(n^{2} )$ $O(1)$ 不稳定 快速 $O(n\\log_{2}{n})$ $O(n^{2} )$ $O(n\\log_{2}{n})$ $O(n\\log_{2}{n})$ 不稳定 堆排序 $O(n\\log_{2}{n})$ $O(n\\log_{2}{n})$ $O(n\\log_{2}{n})$ $O(1)$ 不稳定 归并 $O(n\\log_{2}{n})$ $O(n\\log_{2}{n})$ $O(n\\log_{2}{n})$ $O(n)$ 稳定 桶 $O(n)$ $O(n^{2} )$ $O(n+k)$ $O(n+k)$ 稳定 计数 $O(n+k)$ $O(n+k)$ $O(n+k)$ $O(n+k)$ 稳定 基数 $O(n×k)$ $O(n×k)$ $O(n+k)$ $O(n+k)$ 稳定 记忆技巧：\n稳定性**：快希(些)** 选一堆好友来聊天\n时间快**：快希(些)归**队\n直接插入排序 算法执行步骤：选则后面的无序序列中的第一个值，将他插入到前面的有序序列中的合适位置\n1//代码辅助理解，不用记 2int i,j; 3for(i = 2; i \u0026lt; n; i++){ 4 if(L[i] \u0026lt; L[i-1]){ 5 L[0] = L[i]; 6 for(j = i - 1; L[0] \u0026lt; L[j]; j--){ 7 L[j+1] = L[j]; 8 } 9 L[j+1] = L[0]; 10 } 11} 希尔排序 算法执行步骤：\n1for(dk=n/2;dk\u0026gt;=1;dk=dk/2){ 2 for(i=dk+1;i\u0026lt;=n;i++){ 3 if(L[i]\u0026lt;A[i-dk]){ 4 L[0]=L[i]; 5 for(j=i-dk;j\u0026gt;0\u0026amp;\u0026amp;L[0]\u0026lt;L[j];j-=k){ 6 L[j+dk]=L[j]; 7 } 8 L[j+dk]=L[0]; 9 } 10 } 11} 冒泡排序 快速排序 选择排序 堆排序 归并排序 基数排序 ","permalink":"http://localhost:1313/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","summary":"\u003cp\u003e顺序表主要特点是随机访问，存储密度高，逻辑相邻的元素物理结构上也相邻，插入删除需要移动大量的元素\u003c/p\u003e\n\u003ch1 id=\"队列\"\u003e队列\u003c/h1\u003e\n\u003cp\u003e\u003cstrong\u003e队列的存储结构\u003c/strong\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-C++\" data-lang=\"C++\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e1\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003edefine\u003c/span\u003e \u003cspan class=\"n\"\u003eMaxSize\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e2\u003c/span\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003etypedef\u003c/span\u003e \u003cspan class=\"k\"\u003estruct\u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e3\u003c/span\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003eElemtype\u003c/span\u003e \u003cspan class=\"n\"\u003edata\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003eMaxSize\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e4\u003c/span\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003efront\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\t\u003cspan class=\"c1\"\u003e//队头指针：指向队头元素\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e5\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e        \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ereat\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\t\u003cspan class=\"c1\"\u003e//队尾指针：指向队尾元素的下一个位置\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e6\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"n\"\u003eSqQueue\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e7\u003c/span\u003e\u003cspan class=\"cl\"\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003cstrong\u003e循环队列判空和判满\u003c/strong\u003e：\u003c/p\u003e","title":"数据结构"},{"content":"这是第一篇文章\n行内数学公式：$ a^2 + b^2 = c^2 $。\n块公式，\n$$ a^2 + b^2 = c^2 $$\n$$\r\\boldsymbol{x}_{i+1}+\\boldsymbol{x}_{i+2}=\\boldsymbol{x}_{i+3}\r$$\r1.post-content pre, 2code { 3 font-family: \u0026#34;Roboto\u0026#34;, monospace; 4 font-size: 1rem; 5 line-height: 1.2; 6} 字符串String 设置\nSET key value\n获取 GET key\n删除 DEL key\n判断是否存在 EXISTS key\n查看有哪些键 KEYS [pattern模式匹配]\n删除所有键 FLUSHALL\n查看过期时间 TTL key\n设置过期时间 EXPIRE key time/秒\n设置一个带有过期时间的键值对 SETEX key time value\n当键不存在时设置该键值对 SETNX key value\n列表List 存储或操作一组有顺序的数据\n尾部添加 RPUSH 头部添加 LPUSH 查看 LRANGE key start stop 头删除 RPOP key [删除元素个数] 尾删除 LPOP key [删除元素个数] 指定范围删除 LTRIM key start stop 集合Set 无序集合，不允许重复元素\n添加 SADD key member 判断一个元素是否在集合中 SISMEMBER key member 删除 SREM key member 查看集合元素 SMEMBERS key 有序集合SortedSet 每个元素关联一个浮点类型的分数，按照分数对集合中的元素进行从小到大排序，成员是唯一的，分数是可以重复的\n添加 ZADD key score1 value1 [score2 value2 ……]\n查看\nZRANGE key start end [WITHSCORES]\rWITHSCORES：同时输出分数\r//查看分数\rZSCORE key value\r//查看排名\rZRANK key value 哈希Hash 字符类型的字段和值的映射表，简单来说就是一个键值对的集合，特别适合存储对象\n添加 HEST key field1 value1 [fild2 value2 ……]\n获取 HGET key field\n获取所有键值对 HGETALL key\n删除键值对 HEXISTS key field\n获取所有键 HKEYS key\n获取键的数量\nHLEN key\n发布订阅模式 无法持久化，无法记录历史\n发送：PUBLISH\n接受：SUBSCRIBE 频道名称\n消息队列Stream 轻量级消息队列，解决发布订阅功能的一些局限性，大部分命令用 X 开头\n添加消息 XADD key * field value\n* 表示随机id\nid 格式：整数-整数，第一个整数表示时间戳，第二个整数表示一个序列号，在使用时，需要保证 id 是递增的\n消息数量 XLEN key\n消息详细内容 XRANGE key start end 可以用 - + 表示显示所有内容\n删除 XDEL key ID\n也可以通过XTRIM key MAXLEN 删除消息\n读取消息 XREAD [COUNT 消息数量] [BLOCK 阻塞时间] STREAMS key start\nstart 可以为$符，表示从执行时间开始阻塞，接受最新的消息\n创建消费者组\nXGROUP CREATE 消息名称 组的名称 ID 通过 XINFO GROUPS 消息名称查看消费者组的信息\n添加消费者XGROUP CREATECONSUMER 消息名字 组名字 消费者名字\n读取消息：XREADGROUP GROUP 组名称 消费者名称 COUNT 消息数量 BLOCK 阻塞的时间 STREAMS 消息名称\n地理空间Geospatial 存储地理位置信息的数据结构，支持对地理位置进行各种计算操作，命令以GEO开头\n添加\nGEOADD 信息名字 经度 维度 城市名字 [经度 维度 城市名字 ……]\n获取经纬度\nGEOPOS 信息名字 城市名字\n计算两个地理位置之间的距离\nGEODIST 信息名字 城市名字1 城市名字2\n默认单位是米，在后面加上km为千米\n搜索指定范围内的成员并返回\nGEOSEARCH 信息名字 FROMMEMBER 城市名字1 hyperloglog 做基数统计的算法，使用随机算法来计算，通过牺牲一定的精确度换取更小的内存消耗，优点占用内存小，缺点会有一定的误差，适合做一些对精确度要求不高，而数据量非常大的统计工作\n命令以 PF 开头\n添加元素\nPFADD 元素名 元素1 [元素2 …… 元素n]\n查看基数\nPFCOUNT 元素名\n合并\nPFMERGE new元素名 元素名1 元素名2\n位图Bitmap 由二进制位组成的数组，每个位只能是0或1，可以很方便的存储只有是否两个状态信息的数据\n命令以bit开头\n创建\nSETBIT key bit1 [bit2 …… bitn]\n获取偏移量的值 GETBIT key 偏移量\n批量设置\nSET key \u0026quot;数值\u0026quot;\n位域Bitfield ？？？？？？？？？？？ 将很多小的整数存储到一个较大的位图中\n事务 不能保证所有命令执行成功，执行结果取决于事务中的命令\n主要通过 MULTI 和 EXEC / DESCARD 实现\n在发送 EXEC 命令之前 ，所有命令都会放入一个队列中缓存起来不会立即执行 在收到 EXEC 命令之后，事务开始执行，其中任何一个命令执行失败，其他命令依然会执行 在事务执行过程中，其他客户端提交的命令请求不会被插入到事务的执行命令序列中 持久化 RDB方式 在指定时间内，将内存中的数据快照写入磁盘，是某一个时间点上数据的完整副本，可以通过配置文件中的 save 参数来配置，如果宕机，在最后一次快照之后的数据全部丢失，所以这种方式只适合备份，当为redis开辟的空间比较大，那么写入磁盘的时间会很长，这期间redis处于阻塞状态，不能处理任何求情\n为此，redis提供了一种 bgsave 命令，这个命令会创建一个单独的子进程负责将数据写入磁盘，但是这中间还会有性能损耗，因为fork一个子进程也需要时间，这期间redis也是不能响应请求\nAOF方式 在执行写命令的时候，不仅会写入数据，还会将命令写入到一个追加的文件中，这个文件就是AOF文件，已日志的形式记录每一个写操作，当redis重启之后，会通过执行 AOF 文件中的命令再内存中重建整个数据库的内容\n开启方式 再配置文件中将 appendonly 这个参数的值改成 yes 就可以了\n主从复制 将一台 redis 的数据复制到其他 redis 服务器，主节点和从节点为一对多关系，数据的复制为单向的，只能主到从，一般来说主负责写操作，从负责读操作\n配置方式 默认为主节点，不需要配置\n从节点配置 把配置文件复制到根目录一份 回到根目录，复制一个-6380的文件，作为从节点的配置文件，6380就是从节点的端口号 将 port 改为6380，将pidfile、dbfilename 指向的文件后面添加-6380，pid是进程id，为了和主节点的pid文件区分开 将replicaof 地址改为127.0.0.1，将端口号改为 6379 表示现在配置的这个节点是6379这个库的从节点 链接从节点 redis-cli -p 6380\n链接成功后使用 info replication 查看链接信息\n哨兵模式 自动故障转移，哨兵会以一个独立的进程运行再Redis集群中，用来监控Redis集群中的各个节点是否运行正常，主要功能有：\n监控：通过不断地发送命令，检查Redis节点是否运行正常\n通知：如果发现某个节点出现问题，那么哨兵就会通过发布订阅模式，通知其他节点\n自动故障转移：当主节点不能正常工作的时候，哨兵会开始一个自动故障转移的操作，它会将一个从节点升级为新的主节点，然后再将其他从节点指向新的主节点\n配置步骤：\n1、添加配置文件\rvi sentinel.conf\r添加配置信息 1 表示需要一个哨兵节点同意\rsentinel monitor 主节点名称 127.0.0.1:6379 1\r2、添加哨兵节点\rredis-sentinel 配置文件名字 ","permalink":"http://localhost:1313/posts/my-first-post/","summary":"\u003cp\u003e这是第一篇文章\u003c/p\u003e\n\u003cp\u003e行内数学公式：$ a^2 + b^2 = c^2 $。\u003c/p\u003e\n\u003cp\u003e块公式，\u003c/p\u003e\n\u003cp\u003e$$\na^2 + b^2 = c^2\n$$\u003c/p\u003e\n\u003cdiv\u003e\r\n$$\r\n\\boldsymbol{x}_{i+1}+\\boldsymbol{x}_{i+2}=\\boldsymbol{x}_{i+3}\r\n$$\r\n\u003c/div\u003e\r\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-css\" data-lang=\"css\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e1\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nc\"\u003epost-content\u003c/span\u003e \u003cspan class=\"nt\"\u003epre\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e2\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nt\"\u003ecode\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e3\u003c/span\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003efont-family\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;Roboto\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"kc\"\u003emonospace\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e4\u003c/span\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003efont-size\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"kt\"\u003erem\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e5\u003c/span\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003eline-height\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"mf\"\u003e1.2\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e6\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.postimg.cc/cx5SL93v/image.png\" alt=\"\"  /\u003e\r\n\u003c/p\u003e\n\u003ch1 id=\"字符串string\"\u003e字符串String\u003c/h1\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e设置\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eSET key value\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e获取\n\u003ccode\u003eGET key\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e删除\n\u003ccode\u003eDEL key\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e判断是否存在\n\u003ccode\u003eEXISTS key\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e查看有哪些键\n\u003ccode\u003eKEYS [pattern模式匹配]\u003c/code\u003e\u003c/p\u003e","title":"My First Post"},{"content":"这写一些关于的信息\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e这写一些关于的信息\u003c/p\u003e","title":"关于"}]